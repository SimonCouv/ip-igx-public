---
title: "IgX glycosylation - immunophenotype analysis"
author: 
  - name: "Simon Couvreur"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
    collapsed: false
    code_folding: hide
    number_sections: true
    self_contained: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}

# run chunk to setup script for interactive use


# source("src/imports.R")

figdir <- here("results/figures")
resultdir <- here("results")
cluster_pars_dir <- here("WGCNA_parameters")
datadir <- here("data")

knitr::opts_chunk$set(echo = TRUE,    # in combination with code_folding: hide
                      dev=c("png", "pdf"),
                      fig.path = here("results/figures/report/"))
# automatically switch .png to .pdf in knitr::include_graphics, when rendering to PDF
# https://bookdown.org/yihui/bookdown/figures.html
options(knitr.graphics.auto_pdf = TRUE) 
# vennDiagram uses futile.logger https://stackoverflow.com/questions/33393962/r-dont-write-log-file-for-venndiagram
futile.logger::flog.threshold(futile.logger::ERROR, name = "VennDiagramLogger")


```

```{r functions-source}
# see make.R
# otherwise: self-invalidation, see ?make
```


```{r functions-local}


# 
# tryCatch.W.E_original <- function(expr)
# {
#   W <- NULL
#   w.handler <- function(w){ # warning handler
#     W <<- w
#     invokeRestart("muffleWarning")
#   }
#   # M <- NULL
#   # m.handler <- function(m){ # warning handler
#   #   M <<- m
#   #   # invokeRestart("muffleWarning")
#   # }
#   list(value = withCallingHandlers(tryCatch(expr, error = function(e) e),
#                                    warning = w.handler),
#        warning = W)
# }

# str(tryCatch.W.E(warning("hi")))

```




# Preprocessing

## Load data

Note 618 (13455158 - 13454540) lines were removed, which is more than the 604 mentioned by Alessia.

```{r remove-error-lines}
# 
# f <- file(here("input_data/glycans_20190409_immunopheno_corrected.tsv.gz"), open="r")
# o <- file(here("input_data/glycans_20190409_immunopheno_corrected_cleanedSimon.tsv.gz"), open = "a")
# i <- 1
# 
# while (TRUE){
#   if (i%%100000==0)
#     print(i)
#   
#   line <- readLines(f, n=1)
#   if(str_count(line, "\t")==16){
#     writeLines(text=line, con=o)
#   }
#   i <- i+1
# }
```


```{r read-data}

# glycans
loadd(glycans)
loadd(glycans_raw)

# IPs
loadd(ips)
loadd(ips_raw)

# overlap
loadd(overlap_samples)
loadd(overlap_samples_raw)

loadd(glycans_raw_o)
loadd(glycans_o)

loadd(ips_o)
loadd(ips_raw_o)

# IP missingness
loadd(ip_raw_missing)
loadd(ip_missing)

# after missingness filter
loadd(glycans_omf)
loadd(glycans_raw_omf)

loadd(ips_omf)
loadd(ips_raw_omf)

# overlap after missingness filter
loadd(glycans_omfo)
loadd(glycans_raw_omfo)

loadd(ips_omfo)
loadd(ips_raw_omfo)

# IP mean abundances
loadd(ip_raw_mean)
loadd(ip_mean)

# family-adjusted values
loadd(glycans_fam_adj)
loadd(glycans_qn_fam_adj)
loadd(ips_qn_fam_adj)

# QC: batch effects: quantile normalisated glycans
loadd(glycans_raw_omfo_qn)
# QC: batch effects: riPCA-imputed glycans
loadd(glycans_scaled_ncomp) #list over all datasets
loadd(glycans_scaled_riPCA_imp) #list over all datasets
loadd(glycans_riPCAimp_pca) #list over all datasets
# QC: batch effects: mean-imputed glycans
loadd(glycans_mean_imp) #list over all datasets
loadd(glycans_meanimp_pca) #list over all datasets
# QC: batch effects: formal test
loadd(glycans_gPCA_riPCAimp)
loadd(glycans_gPCA_meanimp)


# Popante results --------------------------------------------------------------
loadd(ip_igx_univar)
loadd(ip_igx_univar_good_anno)

# enrichment
loadd(running_IgG_perc)
loadd(lin_source_props_df)
loadd(lin_source_IgX_props_df)

# annotations
loadd(ip_anno)
ip_anno_dt <- data.table(ip_anno)
loadd(IgA_anno_names_raw)
loadd(IgA_anno_names_derived)
loadd(twin_fam)
loadd(ip_batch)

# WGCNA --------------------------------------------------------------
loadd(glycans_scale_free)
loadd(glycan_module_stats)
loadd(glycans_scale_free_noderiv)
loadd(glycan_module_stats_noderiv)

```

## data preprocessing

```{r QC-filter}

loadd(ip_igx_univar_good)

good_ips <- ip_anno$set_name[ip_anno$robust_mario_qc == "Good"] %>% na.omit()
ips_o_qc <- ips_o %>%
  dplyr::select(!!good_ips)

```

# Data exploration

## Sample overlap

409 participants in intersection of glycans and immunophenotypes. All analyses are restricted to these samples.

```{r}
venn <- venn.diagram(list(ips = ips$IID, igx = glycans$IID), filename = NULL)
grid.draw(venn)
```

Two participants are in intersection of the raw, but not in the corrected glycans and immunophenotypes.

```{r}
setdiff(overlap_samples_raw, overlap_samples)
```


## Glycans

### IgX features

#### Missingness

##### Missing samples per feature

Visual overview, raw glycan data. (Observations clustered and features sorted)

```{r glycan-raw-vis-miss, fig.asp=2.5}
naniar::vis_miss(glycans_raw_o, cluster=TRUE, sort_miss = TRUE)+
  coord_flip()
```

Visual overview, corrected glycan data. (Observations clustered and features sorted)

```{r glycan-corr-vis-miss, fig.asp=2.5}
naniar::vis_miss(glycans_o, cluster=TRUE, sort_miss = TRUE)+
  coord_flip()
```

Histogram of proportion missing samples per feature:

```{r hist-miss-samples-per-feat}
par(mfrow=c(1,2))
hist(colMeans(is.na(glycans_o[-(1:5)])), 15, main = "glycans - corrected", xlab = "proportion missing")
hist(colMeans(is.na(glycans_raw_o[-(1:5)])), 15,  main = "glycans - raw", xlab = "proportion missing")

```

In both raw and corrected glycans, the same 3 features with >20% missingness were dropped.

corrected glycans:

```{r excluded-igx-feat-corr}
glycan_feat_drop <- glycans_o[,-(1:5)] %>%
  dplyr::summarise_all(~mean(is.na(.))) %>% 
  tidyr::gather(feature, prop_missing) %>%
  dplyr::filter(prop_missing > 0.2) %>%
  dplyr::arrange(desc(prop_missing))

glycan_feat_drop %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```

Raw glycans:

```{r excluded-igx-feat-raw}

glycan_feat_drop_raw <- glycans_raw_o[,-(1:5)] %>%
  dplyr::summarise_all(~mean(is.na(.))) %>% 
  tidyr::gather(feature, prop_missing) %>%
  dplyr::filter(prop_missing > 0.2) %>%
  dplyr::arrange(desc(prop_missing))

glycan_feat_drop_raw %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```

##### Missing features per sample (after filtering features)

Visual overview, raw glycan data. (Observations clustered and features sorted)

```{r glycan-raw-vis-miss-2, fig.asp=2.5}
naniar::vis_miss(dplyr::select(glycans_raw_o[-(1:5)], -!!glycan_feat_drop$feature), cluster=TRUE, sort_miss = TRUE)+
  coord_flip()

```

Visual overview, corrected glycan data. (Observations clustered and features sorted)

```{r glycan-corr-vis-miss-2, fig.asp=2.5}
naniar::vis_miss(dplyr::select(glycans_o[-(1:5)], -!!glycan_feat_drop$feature), cluster=TRUE, sort_miss = TRUE)+
  coord_flip()

```

Histogram of percentage missing features per sample:

```{r hist-miss-feat-per-sample}
par(mfrow=c(1,2))
hist(rowMeans(is.na(dplyr::select(glycans_o[-(1:5)], -!!glycan_feat_drop$feature))), 25, main = "glycans - corrected", xlab = "% missing")
hist(rowMeans(is.na(dplyr::select(glycans_raw_o[-(1:5)], -!!glycan_feat_drop$feature))), 25, main = "glycans - raw", xlab = "% missing")

```

Complete samples:

* corrected glycans: `r sum(rowMeans(is.na(dplyr::select(glycans_o[-(1:5)], -!!glycan_feat_drop$feature)))==0)`
* raw glycans: `r sum(rowMeans(is.na(dplyr::select(glycans_raw_o[-(1:5)], -!!glycan_feat_drop_raw$feature)))==0)`

In both raw and corrected glycans, the same 3 samples with > 60% missingness were filtered out:

corrected glycans:

```{r excluded-samples-corr, warning=FALSE}

glycans_o[,-(1:5)] %>%
  as.matrix() %>% 
  t() %>%
  # structure(., colnames = as.character(glycans[,2])) %>%
  as_tibble() %>% 
  set_names(as.character(glycans_o[[2]])) %>%
  dplyr::summarise_all(~mean(is.na(.))) %>% 
  tidyr::gather(IID, prop_missing) %>%
  dplyr::filter(prop_missing > 0.6) %>%
  dplyr::arrange(desc(prop_missing)) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```

Raw glycans:

```{r excluded-sample-raw}

glycans_raw_o[,-(1:5)] %>%
  as.matrix() %>% 
  t() %>%
  # structure(., colnames = as.character(glycans[,2])) %>%
  as_tibble() %>% 
  set_names(as.character(glycans_raw_o[[2]])) %>%
  dplyr::summarise_all(~mean(is.na(.))) %>% 
  tidyr::gather(IID, prop_missing) %>%
  dplyr::filter(prop_missing > 0.6) %>%
  dplyr::arrange(desc(prop_missing)) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```


### Feature annotations

#### IgA

```{r}
# in univariate results
IgA_names_univar <- unique(ip_igx_univar_good$response) %>% .[!str_detect(., pattern = "IgG")]

# in corrected glycan data
IgA_names_input <- names(glycans)[-(1:5)]  %>% .[!str_detect(., pattern = "IgG")]

# n_input == n_results
stopifnot(setequal(IgA_names_univar, IgA_names_input))

# split in raw and derived
IgA_names_univar_raw <- IgA_names_univar[1:71]
IgA_names_univar_derived <- IgA_names_univar[72:99]
```

99 IgA features (equal in input and Poppante results)

- 71 primary
- 28 derived

But the annotations do not perfectly match the features in the data:

- 75 primary
- 52 derived

When examining set diffs:

- 29 __primary__ features from the annotation are not in inputs/results
    - 6 peptide clusters
    - 13 LAGCa/b
    - 10 reason unclear
- 25 __primary__ input/results features are not in annotation  (29-25 = 4 = 75-71)
    - reason unclear for all
- Out of 28 __derived__ input/results names and 52 derived anno names, only 6 are overlapping

__list of differences__:

For primary features:

in anno but not in univar:

```{r}
# annotated names not in input/results -------

#raw
# note: in input/results raw names are coded as e.g. HYT1H2N5F0S2 while in anno they are HYT_H2N5F0S2
setdiff(IgA_anno_names_raw$feature %>% str_replace("_","1"), IgA_names_univar_raw) %T>% 
  writeLines(., glue("{resultdir}/anno_raw_noresult.txt"))
```

in univar but not in anno:

```{r}
setdiff(IgA_names_univar_raw, IgA_anno_names_raw$feature %>% str_replace("_","1")) %T>% 
  writeLines(.,glue("{resultdir}/result_raw_no_anno.txt"))
```


For derived features:

in anno but not in univar:

```{r}
#derived
# note: derived names have same coding in all sets
setdiff(IgA_anno_names_derived$feature, IgA_names_univar_derived)
```

in univar but not in anno:

```{r}
setdiff(IgA_names_univar_derived, IgA_anno_names_derived$feature)
```



```{r}
intersect(IgA_names_univar_derived, IgA_anno_names_derived$feature)
length(union(IgA_names_univar_derived, IgA_anno_names_derived$feature))

```


#### IgG

52 IgG features, but no annotation available yet.

### Marginal distributions

Raw glycans value lie in [0, 100] -> are percentages?

```{r}
glycans_raw_omfo[,-(1:5)] %>% 
  tidyr::gather(feature, value) %>% 
  ggplot(aes(x=feature, y=value))+
  geom_boxplot()

glycans_raw_omfo[,-(1:5)] %>% 
  unlist() %>% 
  summary()

```

Corrected glycans are approximately standard normal:

```{r}

glycans_omfo[,-(1:5)] %>% 
  tidyr::gather(feature, value) %>% 
  ggplot(aes(x=feature, y=value))+
  geom_boxplot()

```

Quantile normalised distributions:

```{r}

glycans_raw_omfo_qn[,-(1:5)] %>% 
  tidyr::gather(feature, value) %>% 
  ggplot(aes(x=feature, y=value))+
  geom_boxplot()

```


see also PDFs



## Immunophenotypes

### Compare raw vs corrected

IIDs `r paste0(setdiff(ips_raw_o$IID, ips_o$IID), collapse=", ")` (rows`r paste0(which(ips_raw_o$IID %in% setdiff(ips_raw_o$IID, ips_o$IID)), collapse=", ")`) have been dropped in the corrected IPs.

```{r}
dim(ips_o)
dim(ips_raw_o)
```



### Feature annotations

#### Overlap feature IDs in data and annotations

1 feature does not have annotations:

```{r}
setdiff(names(ips_raw), ip_anno_dt$set_name)
```


#### Structure of dataset (feature hierarchy)

Overview resolved issues:

* 'xxx.new' in set_name column -> all have source=="P6 newB"
* duplicated subset_names? -> when different plates contains same markers at the top of the hierarchy

Overview open issues:

* "(Ignore)" in canonical_name_x column -> meaning?
* lineage "04-Aug" -> meaning? + inconsistent coding in subset_name column ("4-8")
    - is this some autoformat issue?
* lower-level parent lineages -> mean_value =100% -> where as proportion of higher-level (i.e. containing) lineage?
* NAs in QC columns for plate 6

##### Parent lineage

Cell counts are expressed as proportion of a "parent lineage", this is part before '/' in the subset_name column and also the value in the 'lineage' column (when source is not Lin or MFI). Exception is lineage "04-Aug", which is encoded in the subset_name column as 4-8.

```{r ip-parent-lineage}

# part before slash in subset_name
before_slash <- str_match(ip_anno$subset_name[ip_anno$source != "Lin" & ip_anno$source != "MFI"], pattern = "(.*)/[^/]+")[,2]

# rows indices where part before slash != lineage column
not_eq <- which(before_slash != ip_anno$lineage[ip_anno$source != "Lin" & ip_anno$source != "MFI"])

# ip_anno[ip_anno$source != "Lin" & ip_anno$source != "MFI",] %>% .[not_eq,]
table(before_slash[not_eq])

```

The 44 parent lineages are:

```{r}
ip_anno_dt[phenotype=="*", .(set_name, trait, source, lineage, subset_name, mean_value)][order(lineage)]
# View("parent_lineages")
```

The proportion of features expressed in terms of each parent lineage:

```{r}
ip_anno_dt[source != "Lin" & source != "MFI", .(lineage_perc=round(.N/nrow(ip_anno_dt)*100,2),
                                                lineage_n=.N),
           by=.(lineage)][
             order(-lineage_perc)
             ] %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```


The parent_lineages can be (any of):

* contained within a different parent_lineage: only memory vs naive in CD4 and CD8
* expressed as % of a containing lineage in the source=="Lin" lines: e.g. parent_lineage "4-8-" in "%NKT:4-8-".

Source == lin lines:

```{r source-lin-lines}
ip_anno_dt[source=="Lin", .(set_name, source, lineage, subset_name, mean_value)][order(subset_name)]  %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
# View("source==Lin")

```

While parent_lineage CD4/Memory is contained within parent_lineage CD4, CD4/Memory is not explicitly listed among any of the subsets of CD4.

```{r}
ip_anno_dt[subset_name == "CD4/Memory/"]
ip_anno_dt[subset_name == "CD4/Memory"]
ip_anno_dt[subset_name == "CD4/"]
ip_anno_dt[str_detect(subset_name, pattern="CD4:.*")]


ip_anno_dt[str_detect(subset_name, pattern="CD4/[^/]*$") & source != "Lin" & source != "MFI",
           .(set_name, source, lineage, subset_name, mean_value, phenotype)] %>% 
  mutate(n_marker = str_count(phenotype, pattern="\\-|\\+")) %>% 
  arrange(n_marker) %>%
  head(20) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```

Without clear definition of which marker values define the Memory subset of CD4, the proportion CD4:CD4/Memory cannot be obtained.

More generally, if a measurement is expressed as proportion of a parent_lineage, and the parent_lineage is not either a) expressed  explicitly as a fraction of its containing parent_lineage (in subset_name column), or b) listed among source==Lin lines, the proportion of the measurement relative to higher-order lineages cannot be calculated.

Example: Parent lineage "mDC/1c-/16-" can be traced back as "%mDC:1c-" -> "%Lin-14-:mDC" -> "%Lin-:14-" -> "%Lin-" in the source==Lin lines, but the proportion "mDC/1c-:16-" is missing from the source==Lin lines (see above), nor is the proportion ("mDC/1c-:16-") explicitly expressed elsewhere in the data.

```{r}
# list all features which are expressed as proportion of "mDC/1c-"
ip_anno_dt[str_detect(subset_name, pattern="mDC/1c-/[^/]*$") & source != "Lin" & source != "MFI",
           .(set_name, source, lineage, subset_name, mean_value, phenotype)] %>% 
  mutate(n_marker = str_count(phenotype, pattern="\\-|\\+")) %>% 
  nrow(.)
```

While there are many proportion expressed relative to subsets of "mDC/1c-" (the subsets being "mDC/1c-/16+" and "mDC/1c-/16-").

```{r}
ip_anno_dt[str_detect(subset_name, pattern="mDC/1c-") & source != "Lin" & source != "MFI",
           .(set_name, source, lineage, subset_name, mean_value, phenotype)] %>% 
  mutate(n_marker = str_count(phenotype, pattern="\\-|\\+")) %>% 
  arrange(n_marker) %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```


##### duplicated subset_names

All correspond to subsets which are measured on multiple plates, typically at a high-level of the gating hierarchy (where the lower gates are different between plates). This occurs for CD4, CD8, DPT and DNT

For CD4 & CD8: only the subsets on later plate(s) are labeled as (Ignore)
For DPT & DNT: all subsets are labeled as (Ignore)

Some of the duplicated subsets are parent lineages (where mean_value = 100%), therefore cell count is not relevant. For the others: mean values could be used instead of ignoring all but one?

```{r}
table(ip_anno$source)

sum(duplicated(ip_anno$subset_name))
ip_anno_dt[which(duplicated(subset_name)|duplicated(subset_name, fromLast = TRUE)),
        .(set_name, source, lineage, subset_name, mean_value)][order(subset_name)] %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```

##### (Ignore) labels in canonical_name_x

43,474 IPs have the (Ignore) label.

```{r}
ip_anno_dt[str_detect(canonical_name_x, pattern=".*\\(Ignore\\).*"),
           .(set_name, source, canonical_name_x, lineage, subset_name, mean_value)] %>% 
  head() %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

Does not correspond clearly with the QC columns (neither Max nor Mario).

```{r}

table(ignore=str_detect(ip_anno$canonical_name_x, pattern=".*\\(Ignore\\).*"), 
      max_qc=ip_anno$final_qc_max)
table(ignore=str_detect(ip_anno$canonical_name_x, pattern=".*\\(Ignore\\).*"), 
      mario_qc=ip_anno$robust_mario_qc)

```

Cannot be related to duplication, because much fewer duplicates than (Ignore) labels.

```{r}
table(ignore=str_detect(ip_anno$canonical_name_x, pattern=".*\\(Ignore\\).*"),
      duplicated=duplicated(ip_anno$subset_name)|duplicated(ip_anno$subset_name, fromLast = TRUE))
```


Meaning remains unclear, currently the (Ignore) label is not taken into account.

##### *.new in set_name

Strictly used for source=="P6 newB". Moreover, these subsets make up the large majority (95%) of Panel 6 (P6) subsets.

```{r}
# str_match(ip_anno$set_name, pattern=".*new.*") %>% na.omit(.) %>% View()

table(str_detect(ip_anno$set_name, pattern=".*new.*"), ip_anno$source)
```

#### Missingness in annotation fields

Note: empty fields in immunophenotype annotation set to NA.

No annotation column has more than 20% missing data.

```{r ip_anno_missingness}
# which(is.na(ip_anno$lineage))

#no empty fields in lineage
stopifnot(sum(ip_anno$lineage =="", na.rm = TRUE)==0)

gg_miss_var(ip_anno, show_pct = TRUE)

```

Moreover, the annotation columns relevant to this analysis (lineage and phenotype) are either free of missing data, or (for phenotype and lineage) can be complete traced down to the lines where source=="MFI" or source =="Lin".

```{r}
ip_anno_dt[, table(source, phenotype_NA = is.na(phenotype))]
ip_anno_dt[, table(source, lineage_NA = is.na(lineage))]

```

The 2 QC columns do have some NAs (coded as NA in the flat file), but are not used in this analysis (yet).
NAs occur in the same rows in both QC columns, and exclusively for "P6" and "P6 earlyB", but not for the most frequent "P6 newB".

Presumably Panel 6 was rerun and no QC was performed on the first run because of some clear defect?

```{r}
all(which(is.na(ip_anno$final_qc_max))==which(is.na(ip_anno$robust_mario_qc)))

ip_anno_dt[, table(source, final_QC_NA = is.na(final_qc_max))]

```

#### Define overall grouping of IPs,

To accomodate lineage, MFI and other CSFs, introduce 'composite_lin_source':

- for lineage/MFI features: 'Source' column (value = 'Lin' or 'MFI')
- 'Lineage' column for all others (value=parent lineage on which the subset is calculated)

```{r composite_lin_source_count}
count(ip_anno, composite_lin_source) %>% 
  arrange(desc(n))
  # View()
  
```

### Features

overall 3.4% missing:

```{r}
mean(ip_missing$missing_prop)
```


#### Missing samples per feature

Histogram of proportion missing samples per feature:

```{r}
par(mfrow=c(1,2))
boxplot(ip_missing$missing_prop)
abline(h = 0.2, col = "red")
boxplot(ip_raw_missing$missing_prop)
abline(h = 0.2, col = "red")
# ggplot(ip_missing, aes(x="",y=missing_prop))+
#   geom_boxplot()
# plot(ecdf(ip_missing$missing_prop))

```

Per-feature proportion missing is maintained between the raw and corrected datasets (maximally around 1% difference).

```{r}
setkey(ip_missing, set_name)
setkey(ip_raw_missing, set_name)
merge(ip_raw_missing, ip_missing, all=FALSE, suffixes = c("_raw", "_corrected"))[
  , .(diff_perc=abs(missing_prop_raw - missing_prop_corrected)/pmin(missing_prop_raw, missing_prop_corrected)*100)
][order(-diff_perc)] %>%
  ggplot(aes(x="", y=diff_perc))+
  geom_boxplot()+
  stat_n_text()

```

```{r excluded-ip-feat}
ip_feat_drop <- ip_missing[missing_prop > 0.2,][ip_anno_dt, .(set_name, subset_name, missing_prop),on="set_name", nomatch=0][order(-missing_prop)]
ip_feat_drop_raw <- ip_raw_missing[missing_prop > 0.2,][ip_anno_dt, .(set_name, subset_name, missing_prop),on="set_name", nomatch=0][order(-missing_prop)]
stopifnot(setequal(ip_feat_drop$set_name, ip_feat_drop_raw$set_name))
```

In both raw and corrected IPs, the same 59 features with >20% missingness were dropped.

```{r excluded-ip-feat-print}
ip_feat_drop %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

#### Missing features per sample (after filtering features)

```{r ips-missing-features-per-sample}

par(mfrow=c(1,2))
hist(rowMeans(is.na(ips_o[, !ip_feat_drop$set_name, with=FALSE])), 25, main = "ips - corrected", xlab = "% missing")
hist(rowMeans(is.na(ips_raw_o[, !ip_feat_drop_raw$set_name, with=FALSE])), 25, main = "ips - raw", xlab = "% missing")

```

Complete samples:

* corrected IPs: `r sum(rowMeans(is.na(ips_o[, !ip_feat_drop$set_name, with=FALSE]))==0)`
* raw IPs: `r sum(rowMeans(is.na(ips_raw_o[, !ip_feat_drop_raw$set_name, with=FALSE]))==0)`

In both raw and corrected IPs, 4 samples with > 60% missingness were filtered out:

```{r}

ips_sample_drop <- ips_o[,
      .(missing_prop = rowMeans(is.na(ips_o[, !ip_feat_drop$set_name, with=FALSE])),
        IID,
        FID)
      ][
        missing_prop > 0.6,.(IID, FID, missing_prop)
        ]

ips_sample_drop_raw <- ips_raw_o[,
      .(missing_prop = rowMeans(is.na(ips_raw_o[, !ip_feat_drop_raw$set_name, with=FALSE])),
        IID,
        FID)
      ][
        missing_prop > 0.6,.(IID, FID, missing_prop)
        ]

stopifnot(setequal(ips_sample_drop$IID, ips_sample_drop_raw$IID))
ips_sample_drop %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```


In missingness-filtered and overlapped dataset: 2.5% missing:

```{r}
mean(is.na(ips_raw_omfo))
```


#### Low frequency IPs

##### Replicate strategy Roederer2015

From Roederer2015:

"more than one third were eliminated from analyses as they represented subset frequencies that were too low for robust analysis (less than 0.1% of the parental ‘‘lineage’’ gate)." (Fig S4)

and 

"First, we eliminated those CSFs whose mean frequency (within their parent ‘‘lineage’’) was below 0.1% or above 99%" (section "Selection of Subsets for Heritability and GWAS Analysis", p S2)

First attempt: calculate per-IP total signal over samples, and express as proportion of per-lineage (column 'lineage' in ip_anno) sum of per-IP totals

But problem:'tri-boolean' gates are partially overlapping -> parent lineage signal < sum(contained signals)

```{r low-freq-ips}
# data.table for speed
# by taking mean (rather than sum) per feature, downstream analysis is not affected by per-feature proportion missing

# join in lineage info
# https://stackoverflow.com/questions/30944116/r-data-table-subgroup-weighted-percent-of-group
setkey(ip_raw_mean, set_name)
setkey(ip_anno_dt, set_name)
ip_raw_mean[ip_anno_dt[source != "Lin" & source != "MFI",.(set_name, lineage)], 
            nomatch=0][
              , 
              .(mean_sign = mean_signal, 
                  tot_lin_signal = sum(mean_signal),
                  prop = mean_signal/sum(mean_signal)),
              by=lineage
              ] %>%
  head() %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

```

New approach: treat relative cell counts 'as-is'. The two quotes above differ in whether subsets above 99% are also discarded or not.

```{r low-freq-ips2}
ip_raw_mean[, table(mean_signal < 1e-3 | mean_signal >0.99)]
ip_raw_mean[, table(mean_signal < 1e-3)]
ip_raw_mean[, table(mean_signal >0.99)]

```

Only a small proportion of subsets are below 0.1% relative frequency. In contrast, with the criterion of excluding both low and high relative frequency subsets (as in Roederer2015, section "Selection of Subsets for Heritability and GWAS Analysis"), the proportion of subsets which fit this definition (42%) is roughly similar to Roederer2015 (37%).

```{r}

mean(ip_raw_mean[,mean_signal < 1e-3 | mean_signal >0.99])

# Roederer2015
1-49928/78683
```

##### IP frequency distribution

```{r ip-freq-distr}

ip_raw_mean[order(-mean_signal)]
ip_mean[order(-mean_signal)]

boxplot(ip_raw_mean[, mean_signal])
boxplot(ip_mean[, mean_signal])

```

#### Marginal distributions

```{r}
variances <- apply(ips_raw_omfo[,-(1:2)],2,var, na.rm=TRUE)
means <- apply(ips_raw_omfo[,-(1:2)],2,mean, na.rm=TRUE)
CVs <- sqrt(variances)/abs(means)

feature_sumstat_df <- cbind(means, variances, CVs, feature = names(ips_raw_omfo)[-(1:2)]) %>% 
  as_tibble() %>%
  tidyr::gather(statistic, value, -feature) %>% 
  left_join(ip_anno[c("set_name", "composite_lin_source")], by=c("feature"="set_name")) %>% 
  mutate(type=ifelse(composite_lin_source=="MFI", "SPEL", "CSF"),
         value=as.numeric(value))

feature_sumstat_df %>% 
  mutate(value=as.numeric(value)) %>% 
  nest(-one_of("type","statistic")) %>% 
  drop_na() %>% 
  mutate(quantiles = map(data, ~quantile(.x$value, na.rm = TRUE)),
         quantiles2=map(quantiles, ~bind_rows(.x) %>% tidyr::gather())) %>% 
  unnest(quantiles2)  %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

sumstat_p <-feature_sumstat_df %>% 
  drop_na() %>% 
  ggplot(aes(x="", y=value))+
  geom_boxplot()+
  facet_wrap(~type+statistic, scales="free")

sumstat_p

```


```{r}

sum(variances==0)

```


see also PDF for subset of IPs

## Sample overlap of missingness-filtered datasets

The same 4 samples are filtered out in raw and corrected glycans. The same 3 samples are filtered out in raw and corrected immunophenotypes. (see respective sections above)

The 2 samples in the intersection of raw datasets but not in the intersection of corrected datasets are the same as in the intersection before filtering:

```{r}
setdiff(ips_raw_omf$IID, ips_omf$IID)
```


Corrected:

```{r}
venn <- venn.diagram(list(ips = ips_omf$IID, igx = glycans_omf$IID), filename = NULL)
grid.draw(venn)
```

Raw:

```{r}
venn <- venn.diagram(list(ips = ips_raw_omf$IID, igx = glycans_raw_omf$IID), filename = NULL)
grid.draw(venn)
```


## Batch effects/global differences between samples

see notes 30/04: concern is any sample-specific biases, but plate/batch is only available metadata to study these -> focus on batch effects
After meeting 2/5: less focus on batch effects. More importantly: glycans are compositional data

### glycans

Limited variation in per-sample sums.

```{r}
boxplot(apply(glycans_raw_omfo[,-(1:5)], 1, sum))
```

coef. var  = 1.7%

```{r}
sd(apply(glycans_raw_omfo[,-(1:5)], 1, sum), na.rm = TRUE)/mean(apply(glycans_raw_omfo[,-(1:5)], 1, sum), na.rm = TRUE)
# sd(apply(glycans_raw[,-(1:5)], 1, mean), na.rm = TRUE)/mean(apply(glycans_raw[,-(1:5)], 1, mean), na.rm = TRUE)
```

#### Experimental design glycans

```{r exp-design-overlap}

design_overlap <- glycans_raw[,1:5] %>%
  dplyr::left_join(twin_fam, by=c("FID"="Family_No", "IID"="STUDY_NO", "Sex"="SEX")) %>% 
  dplyr::filter(IID %in% ips_raw$IID) 

ggplot(design_overlap, aes(x=factor(Plate_NO), fill=ETHNICITY))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(design_overlap, aes(x=factor(Plate_NO), fill=ACTUAL_ZYGOSITY))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(design_overlap, aes(x=factor(Plate_NO), fill=Sex))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(design_overlap, aes(x=factor(Plate_NO), y=Age))+
  geom_boxplot()+
  stat_n_text()

```


#### Quantile normalisation

Scaling important before quantile normalisation, because otherwise all samples get assigned the same values and all variance is removed from features. Extreme example:

lowest value per sample is always v1, second is always v2, etc

mean of lowest values is just mean of v1, mean of second lowest is just mean of v2, etc

each sample gets assigned exactly the same values

```{r qn-simulation}

toy_df <- seq(-50,50,by=10) %>% 
  map(~rnorm(200, mean=.x,sd=3)) %>% 
  bind_cols() %>% 
  as.matrix()

# simulate some batch effect
toy_batch <- rep(1:5, each=40)
# toy_batch_effect <- rep(seq(0.6,1.4,by=0.2), each=40)
# toy_df_batch <- toy_df*toy_batch_effect
toy_batch_effect <- rep(seq(-1,1,by=0.5), each=40)
toy_df_batch <- toy_df+toy_batch_effect

#scale features
toy_df_batch_scale <- scale(toy_df_batch)

# quantile normalise
toy_df_qn <- t(normalize.quantiles(t(toy_df_batch)))  #per quantile, the corresponding feature is identical for each sample -> 
toy_df_scale_qn <- t(normalize.quantiles(t(toy_df_batch_scale)))

par(mfrow=c(1,2))
boxplot(toy_df, main="variables [before batch effect]")
boxplot(t(toy_df), main="samples [before batch effect]")

boxplot(toy_df_batch, main="variables [batch effect]")
boxplot(t(toy_df_batch), main="samples [batch effect]")

boxplot(toy_df_batch_scale, main="variables [BE, variables scaled]")
boxplot(t(toy_df_batch_scale), main="samples [BE, variables scaled]")

boxplot(toy_df_qn, main="variables [with BE] QN")
boxplot(toy_df_scale_qn, main="variables [with BE, scaled] QN")

boxplot(t(toy_df_qn), main="samples [with BE] QN")
boxplot(t(toy_df_scale_qn), main="samples [with BE, scaled] QN")

corrplot::corrplot(cor(toy_df), method = "color", type = "lower", main="truth", col=blueWhiteRed(100))
hist(ifelse(1-diag(11),cor(toy_df), NA), main="truth")

corrplot::corrplot(cor(toy_df_batch), method = "color", type = "lower", main="batch", col=blueWhiteRed(100))
hist(ifelse(1-diag(11),cor(toy_df_batch), NA), main="batch")

corrplot::corrplot(cor(toy_df_qn), method = "color", type = "lower", main="qn", col=blueWhiteRed(100))
hist(ifelse(1-diag(11),cor(toy_df_qn), NA), main="qn")

corrplot::corrplot(cor(toy_df_scale_qn), method = "color", type = "lower", main="scale qn", col=blueWhiteRed(100))
hist(ifelse(1-diag(11),cor(toy_df_scale_qn), NA), main="scale qn")

par(mfrow=c(1,1))




```


#### regularised iterative PCA imputation (integrated imputation and PCA)

Goal: compare principal components between batches, for different datasets:

- 'raw' glycan data
- glycan data corrected for age*sex + (1|batch)
- scaled, then quantile normalised glycan data
- glycan data adjusted via lmer(glycan ~ (1|FID) + Plate_NO + Age)
- scaled, then quantile normalized glycan data adjusted via lmer(glycan ~ (1|FID) + Age))

```{r}

par(mfrow=c(2,1))
boxplot(glycans_raw_omfo[,-(1:5)], main="raw")
boxplot(glycans_scaled_imp$raw$completeObs, main="raw - scaled, imputed")
boxplot(glycans_omfo[,-(1:5)], main="corrected: glycan ~ age*sex+ (1|plate)")
boxplot(glycans_raw_omfo_qn[,-(1:5)], main="qn")
boxplot(glycans_fam_adj, main="famajd: glycan ~ (1|FID) + plate + Age")
boxplot(glycans_qn_fam_adj, main="qn_famadj: glycan ~ (1|FID) + Age)")

```

problem: missing data. proportion missing (in raw glycan data)=

```{r}
mean(is.na(glycans_raw_omfo[,-(1:5)]))
```

solution: regularised iterative PCA, cf @josseHandlingMissingValues2012; @josseMissMDAPackageHandling2016.

Assess riPCA imputation. Imputation is generally of poor quality, especially for O-linked IgA glycans (HYT...). Consider using different imputation technique.

```{r}

readd(p_riPCA_input_impute_comparison)

```

Confirmation of mean imputation:

```{r}

readd(p_mean_input_impute_comparison)

```


Result of PCA on scaled, then PCA-imputed glycans:

```{r PCA-impute}

# % variance explained
map(glycans_scaled_pca, "eig") %>% 
  map(head, 10)

```

#### Visual assessment of PCs per plate 

Boxplots PCs per plate, with riPCA-imputed data (but see quality of imputation above).

```{r warning=FALSE, out.width='100%'}
plot_npc <- 5
# cbind PCs with plate numbers
pc_plot_data <-  map2(
    .x = glycans_riPCAimp_pca,
    .y = list(glycans_raw_omfo,
              glycans_omfo,
              glycans_raw_omfo_qn,
              glycans_raw_omfo,
              glycans_raw_omfo),
    .f = function(x,y,...){
      cbind(y[, 'Plate_NO'], x$ind$coord[,1:plot_npc])
    },
  ) %>%

  # gather, clean then combine datasets in single df for plotting
  purrr::map(~ group_by(.x, Plate_NO) %>% 
               mutate(n_plate=n(),
                      plate_long = glue("{Plate_NO} (n={n_plate})")) %>% 
               tidyr::gather( PC, value, -one_of(c("Plate_NO", "n_plate", "plate_long")))
               # dplyr::mutate(PC = factor(PC, levels = paste0("Dim.", 1:15)))
             ) %>% 
  set_names(c("raw", "lmer(glycan ~ \nage*sex+ (1|plate))", "scaled, QN", "lmer(glycan ~ \n(1|FID) + plate + age)", "scaled, QN\n, glycan ~ (1|FID) + Age)")) %>% 
  bind_rows(.id="dataset")
  
# make boxplot
ggplot(pc_plot_data, aes(x=as.factor(plate_long), y=value, fill=dataset))+
  geom_boxplot(show.legend = FALSE)+
  # stat_n_text(y.pos = -30)+
  facet_grid(dataset~PC, scales="free")+
  scale_fill_discrete(name=NA)+
  coord_flip()+
  xlab("plate")+
  ylab("PC value")


```

With mean-imputed data

```{r warning=FALSE, out.width='100%'}
plot_npc <- 5
# cbind PCs with plate numbers
pc_plot_data <-  map2(
    .x = glycans_meanimp_pca,
    .y = list(glycans_raw_omfo,
              glycans_omfo,
              glycans_raw_omfo_qn,
              glycans_raw_omfo,
              glycans_raw_omfo),
    .f = function(x,y,...){
      cbind(y[, 'Plate_NO'], x$ind$coord[,1:plot_npc])
    },
  ) %>%

  # gather, clean then combine datasets in single df for plotting
  purrr::map(~ group_by(.x, Plate_NO) %>% 
               mutate(n_plate=n(),
                      plate_long = glue("{Plate_NO} (n={n_plate})")) %>% 
               tidyr::gather( PC, value, -one_of(c("Plate_NO", "n_plate", "plate_long")))
               # dplyr::mutate(PC = factor(PC, levels = paste0("Dim.", 1:15)))
             ) %>% 
  set_names(c("raw", "lmer(glycan ~ \nage*sex+ (1|plate))", "scaled, QN", "lmer(glycan ~ \n(1|FID) + plate + age)", "scaled, QN\n, glycan ~ (1|FID) + Age)")) %>% 
  bind_rows(.id="dataset")
  
# make boxplot
ggplot(pc_plot_data, aes(x=as.factor(plate_long), y=value, fill=dataset))+
  geom_boxplot(show.legend = FALSE)+
  # stat_n_text(y.pos = -30)+
  facet_grid(dataset~PC, scales="free")+
  scale_fill_discrete(name=NA)+
  coord_flip()+
  xlab("plate")+
  ylab("PC value")


```

#### Hierarchical clustering of samples

```{r, eval=FALSE}

data <- glycans_scaled_imp$raw$completeObs
sc <- scale(data)

par(mfrow=c(2,1))
boxplot(data)
boxplot(sc)

# hierarchical clustering
d <- dist(sc, method = "euclidean")
hc <- hclust(d, method = "average")

Heatmap(sc,
        cluster_rows = hc,
        cluster_columns = FALSE)+
  HeatmapAnnotation(df = data.frame(factor(glycans_raw_omfo$Plate_NO)), which = "row")

# kmeans
Heatmap(
  sc,
  cluster_rows = TRUE,
  clustering_method_rows = "average",
  km = n_distinct(glycans_raw_omfo$Plate_NO),
  cluster_columns = FALSE)+
  HeatmapAnnotation(df = data.frame(factor(glycans_raw_omfo$Plate_NO)), which = "row")

km <- kmeans(sc, centers = n_distinct(glycans_raw_omfo$Plate_NO))



dist(bind_rows(glycans_raw[1,-(1:5)], glycans_raw[35,-(1:5)]))
all(is.na(glycans_raw[1,-(1:5)]) | is.na(glycans_raw[35,-(1:5)]))

```

#### Formal test: gPCA

No strong batch effects 

```{r}

map(glycans_gPCA_meanimp, "p.val")
map(glycans_gPCA_riPCAimp, "p.val")

```

For reference, correlation distribution of micro-array data in Reese2013.

```{r eval=FALSE}
library(gPCA)
data("caseDat")  # in drake::make error: cannot add bindings to a locked environment
# data("lowpheDat") # unavailable

casedat_cor <- cor(caseDat$data)
hist(casedat_cor)
```



### IPs

#### Experimental design

2 samples have no information on batch.

```{r}
ip_design_omfo <- ips_raw_omfo[,1:2] %>% 
  left_join(twin_fam, by=c("FID"="Family_No", "IID"="STUDY_NO")) %>% 
  left_join(ip_batch, by=c("FID", "IID")) 

# summarise_all(ip_design_omfo, function(x)mean(is.na(x)))
summarise_all(ip_design_omfo, function(x)sum(is.na(x)))

dplyr::filter(ip_design_omfo, is.na(batch))

```


```{r}

ggplot(ip_design_omfo, aes(x=factor(batch), fill=ETHNICITY))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(ip_design_omfo, aes(x=factor(batch), fill=ACTUAL_ZYGOSITY))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(ip_design_omfo, aes(x=factor(batch), fill=SEX))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(ip_design_omfo, aes(x=factor(batch), y=age))+
  geom_boxplot()+
  stat_n_text()
  
```




# Analysis of univariate results

## Quality control

p-value QQ-plot:

```{r univar-qq}

knitr::include_graphics(here::here("results/figures/univar_qqplot.png"))

```


## Number of significant associations ~ FDR threshold

```{r n-sign-ass-FDR}
plot(ecdf(ip_igx_univar_good$pv_adj_global),
     xlab = "FDR",
     ylab = "prop associations < FDR")

ip_igx_univar_good %>%
  summarise(n_FDR20 = sum(pv_adj_global <0.2),
            n_FDR10 = sum(pv_adj_global <0.1),
            n_FDR5 = sum(pv_adj_global <0.05),
            n_FDR1 = sum(pv_adj_global <0.01))

ecdf_abs <- function(x){
  e <- ecdf(x)
  function(t){e(t)*length(x)}
}
ecdf_logabs <- function(x){
  e <- ecdf(x)
  function(t){log10(e(t)*length(x))}
}

fdr20_ecdf <- ecdf_abs(ip_igx_univar_good$pv_adj_global %>% .[. < 0.2])
plot(fdr20_ecdf, xlim = c(0,0.2),
     xlab = "FDR",
     ylab = "n associations < FDR")

fdr_ecdf <- ecdf_abs(ip_igx_univar_good$pv_adj_global)
plot(fdr_ecdf,
     xlab = "FDR",
     ylab = "n associations < FDR")

fdr_log_ecdf <- ecdf_logabs(ip_igx_univar_good$pv_adj_global)
plot(fdr_log_ecdf,
     xlab = "FDR",
     ylab = "log10(n associations < FDR)")

```

## Number of significantly associated features per omic ~ FDR threshold


```{r n-sign-ass-features-FDR}

loadd(n_associated_m)

ggplot(ungroup(n_associated_m), aes(x=fdr_threshold, y=prop, colour=omic))+
  geom_line()+
  theme_bw()+
  # facet_zoom(x = fdr_threshold < 0.25)
  facet_zoom(xlim = c(0,0.2))+
  xlab("FDR threshold")+
  ylab("proportion of features with association < FDR")

```


## Explore top associations



```{r top-associations}



# arrange(ip_igx_univar_good_anno, pvalue) %>% dplyr::select(response, IgX, predictor, composite_lin_source, pvalue) %>% head(100)

# ip_igx_univar_good_anno %>%
#   head(10000) %>% 
#   count(IgX, composite_lin_source)%>%
#   arrange(IgX, desc(n)) 
  # View()


```


### Top asssociations scatter
see PDF

### Enrichment of subgroups

#### At 5% FDR level

##### IP subgroup enrichment - overall

```{r ip-enrich-overall}

ip_lin_source_enrich_overall <- ip_igx_univar_good_anno %>%
  dplyr::filter(pv_adj_global < 0.05) %>%
  count(composite_lin_source) %>%
  left_join(count(ip_anno, composite_lin_source),
            by = "composite_lin_source", 
            suffix = c("_assoc", "_feat")) %>% 
  mutate(`n_assoc/n_feat` = n_assoc/n_feat,
         `prop(n_assoc)` = n_assoc/sum(n_assoc)
         # `prop(n_assoc/n_feat)` = `n_assoc/n_feat`/sum(`n_assoc/n_feat`)
         ) %>% 
  dplyr::select(composite_lin_source, n_assoc, n_feat, `n_assoc/n_feat`, everything()) %>% 
  arrange(desc(`n_assoc/n_feat`))

ip_lin_source_enrich_overall %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

write_csv(ip_lin_source_enrich_overall, path = glue("{resultdir}/ip_lin_source_enrich_overall.csv"))

```

##### IP subgroup enrichment - by IgX

```{r ip-enrich-byIgX}

ip_lin_source_enrich_byIgX <- ip_igx_univar_good_anno %>%
  dplyr::filter(pv_adj_global < 0.05) %>%
  count(composite_lin_source, IgX) %>%
  left_join(count(ip_anno, composite_lin_source),
            by = "composite_lin_source", 
            suffix = c("_assoc", "_feat")) %>% 
  group_by(IgX) %>% 
  mutate(`n_assoc/n_feat` = n_assoc/n_feat,
         `prop(n_assoc)` = n_assoc/sum(n_assoc)
         # `prop(n_assoc/n_feat)` = `n_assoc/n_feat`/sum(`n_assoc/n_feat`)
         ) %>% 
  dplyr::select( IgX,composite_lin_source, n_assoc, n_feat, `n_assoc/n_feat`, everything()) %>% 
  arrange(IgX, desc(`n_assoc/n_feat`))

ip_lin_source_enrich_byIgX %>%
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

write_csv(ip_lin_source_enrich_byIgX, path = glue("{resultdir}/ip_lin_source_enrich_byIgX.csv"))


```


#### continuous ~ FDR

##### IgX subgroup enrichment

```{r glycan-IgG-enrich_cont}

# running_IgG_perc <- c()
# for (i in 1:nrow(ip_igx_univar_good)){
#   running_IgG_perc <- head(ip_igx_univar_good$response, i) %>% str_detect(., pattern = "IgG") %>% mean(.)
# }

p_IgG_enrich <- tibble(cum_IgG_perc = running_IgG_perc,
                       index = 1:length(running_IgG_perc)) %>% 
  .[c(1:10000,seq(10000,length(running_IgG_perc), 100)),] %>%
  ggplot(aes(x=index,y=cum_IgG_perc))+
  geom_line()+
  scale_x_log10()

## gssave not require once Rmd becomes easily renderable
# ggsave(p_IgG_enrich, filename = glue("{figdir}/p_IgG_enrich.png"),
#        width = 6, height = 6, dpi = 600)

p_IgG_enrich

```

##### IP subgroup enrichment

Overall:

```{r ip-lin_source-enrich_cont}



p_lin_source_enrich <- lin_source_props_df %>%
  tidyr::gather(lin_source, prop, -one_of("top","weighting")) %>%
  ggplot(aes(x=top, y=prop, color=lin_source, group=lin_source))+
  geom_line()+
  scale_x_log10()+
  facet_wrap(weighting~.)
# ggsave(p_lin_source_enrich, filename = glue("{figdir}/p_lin_source_enrich.png"),
#        width = 6, height = 6, dpi = 600)

p_lin_source_enrich

```

By IgX:

```{r lin_source-enrich-by-IgX_cont}



# plot
p_lin_source_IgX_enrich <- lin_source_IgX_props_df %>%
  tidyr::gather(lin_source, prop, -one_of(c("top", "IgX"))) %>%
  ggplot(aes(x=top, y=prop, color=lin_source, group=lin_source))+
  geom_line()+
  scale_x_log10()+
  facet_grid(IgX~.)
# ggsave(p_lin_source_IgX_enrich, filename = glue("{figdir}/p_lin_source_IgX_enrich.png"),
#        width = 6, height = 6, dpi = 600)

p_lin_source_IgX_enrich

```


# Correlation structures


## Family clustering

### Options to deal with family clustering

* work with residuals of linear mixed effect model
    - problem MZ&DZ treated the same
    - kinship2::kinship + coxme::lmekin 
        +for historical remarks about the libraries see https://cran.r-project.org/web/packages/coxme/vignettes/lmekin.pdf
* explicitly model family structure to calculate correlations
* use PopPAnTe? IF variables in regression are on same scale, correlation coefficient = regression coefficient (https://en.wikipedia.org/wiki/Simple_linear_regression#Fitting_the_regression_line)
    + links to question of quantile-normalisation (see above, batch effects)

### bivariate multi-level model

#### Literature on estimation of bivariate correlation from clustered/multi-level/hierarchical samples

Problem statement: for each sample two or more variables are observed, but samples are correlated (here, due to being twins).

unanswered SO on same subject: https://stats.stackexchange.com/questions/81220/multivariate-mixed-model-in-nlme

Extra catch: would need to re-implement/by-pass first phases of WGCNA, because these only take raw data, not pre-computed correlations


*Excellent ref:*

Luo, J., D’Angelo, G., Gao, F., Ding, J., Xiong, C., 2015. Bivariate correlation coefficients in family-type clustered studies. Biometrical Journal 57, 1084–1109. https://doi.org/10.1002/bimj.201400131

- three type of correlations, "unconditional marginal bivariate correlation coefficient" is what is needed.

*But how to implement?*

From following refs it seems that only within-cluster BCC is estimable with lme4.

However, the model of Luo2015 is also implemented on melted data! (see their appendix)

method via melting the data (multivariate -> repeated measures) in lme4
https://mac-theobio.github.io/QMEE/MultivariateMixed.html#a-trick-to-do-multivariate-mixed-models-using-lme4
http://rpubs.com/bbolker/3336
https://stackoverflow.com/questions/7831243/multivariate-linear-mixed-model-in-lme4



Other refs:
Lorenz, D.J., Datta, S., Harkema, S.J., 2011. Marginal association measures for clustered data. Stat Med 30, 3181–3191. https://doi.org/10.1002/sim.4368
Bland, J.M., Altman, D.G., 1995a. Statistics notes: Calculating correlation coefficients with repeated observations: Part 1—correlation within subjects. BMJ 310, 446. https://doi.org/10.1136/bmj.310.6977.446
Bland, J.M., Altman, D.G., 1995b. Calculating correlation coefficients with repeated observations: Part 2—correlation between subjects. BMJ 310, 633. https://doi.org/10.1136/bmj.310.6980.633
Meinck, S., Rodriguez, M.C., 2013. Considerations for correlation analysis using clustered data: working with the teacher education and development study in mathematics (TEDS-M) and other international studies. Large-scale Assessments in Education 1, 7. https://doi.org/10.1186/2196-0739-1-7
Rosner, B., Glynn, R.J., 2017. Estimation of rank correlation for clustered data. Statistics in Medicine 36, 2163–2186. https://doi.org/10.1002/sim.7257
Rosner, R., 2016. Marginal Association Measures for Clustered Data.

### correlation of LME residuals

#### LMM assumptions



#### Within-modality

##### Glycans

###### V1: plate as mixed effect

Groups are non-nested, in the sense of Gelman2007, p244 ("overlapping categories"). This implies that HLMdiag *cannot* be used.

```{r glycan-lmer-plate-random, eval=FALSE}

glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age + (1|Plate_NO),
                    glycans_raw_omfo %>% 
                      dplyr::mutate_at(.vars = vars(FID,IID,Plate_NO, Sex), as.factor)
                    )

# gives boundary fit (see ?isSingular)


# adjust all glycans
glycans_fam_adj_l <- list()
fits <- warns <- msgs <- list()
for (i in 6:ncol(glycans_raw_omfo)){
  
  # debug
  # i <- 7
  
  igx <- names(glycans_raw_omfo)[i]
  model_data <- cbind(glycans_raw_omfo[,1:5],
                      structure(glycans_raw_omfo[, ..i], names="glycan")) %>%
    dplyr::mutate_at(.vars = vars(FID,IID,Plate_NO, Sex), as.factor)
  tmp <- tryCatch.W.E(
    lmer(glycan ~ (1|FID) + (1|Plate_NO) + Sex*Age, model_data)
    )
  fits[[igx]] <- tmp$value
  warns[[igx]] <- tmp$warning
  msgs[[igx]] <- tmp$message
  
  glycans_fam_adj_l[[igx]] <- residuals(fits[[igx]])
}


glycans_fam_adj_old <-glycans_fam_adj_l %>%
  purrr::map(~tibble(res=.x, index=names(.x)) %>%
        dplyr::right_join(tibble(index=as.character(1:nrow(glycans_raw))), by="index") %>%
        dplyr::select(res)) %>%
  dplyr::bind_cols() %>%
  rlang::set_names(names(glycans_fam_adj_l))



```


###### Troubleshoot

####### Problem outline

Problems:

* isSingular message for 80/151 glycans
* convergence warning for 10/151 glycans


Troubleshoot resources:
FAQ at https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html
  (sections "Convergence warnings" and "Singular models)
  
Convergence resources:
 * ?convergence
 * lme4 convergence warnings: troubleshooting at https://rstudio-pubs-static.s3.amazonaws.com/33653_57fc7b8e5d484c909b615d8633c01d51.html
 
 Singularity resources:
 * https://stats.stackexchange.com/questions/378939/dealing-with-singular-fit-in-mixed-models


```{r glycan-lmer-plate-random-troubleshoot, eval=FALSE}
# reason for boundary fit: not that FID and plate are strictly aliased
dplyr::summarise_all(glycans_raw_omfo[,1:4],n_distinct)
glycans_raw_omfo %>%
  dplyr::group_by(FID) %>%
  dplyr::summarise(n_plates = n_distinct(Plate_NO)) %>%
  dplyr::count(n_plates)
# rather it seems that plate_NO is generating the warnings
glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|Plate_NO), glycans_raw_omfo)  # not ok
summary(glycans_fit)   # var(plate_NO)=0
glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age, glycans_raw_omfo)  # ok


## co-occurrence pattern of singularity messages and convergence warnings

# var(plate_no) is non-zero for 63% of glycans
plate_var <- fits %>%
  purrr::map(~broom::tidy(.x)) %>%
  purrr::map(~dplyr::filter(.x, term=="sd_(Intercept).Plate_NO")) %>%
  purrr::map_dbl("estimate")

boxplot(plate_var)
mean(plate_var==0)
plate_var_overview <- tibble(glycan=names(plate_var),
       plate_var=plate_var,
       msg = (glycan %in% names(msgs)),
       warn = (glycan %in% names(warns)))
# View(plate_var_overview)
# for isSingular message, there is a clear trend with plate_var
# for non-convergence warning, there does not seem to be such trend
plate_var_overview %>%
  tidyr::gather(output_type, value, -one_of("glycan", "plate_var")) %>%
  ggplot(aes(x=value, y=plate_var))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~output_type)+
  stat_n_text()


```


####### Try different optimizers (allFit), following ?convergence

IgG4_A2G has only the convergence problem.


```{r glycan-lmer-plate-random-allfit, eval=FALSE}
fit <- lmer(IgG4_A2G ~ (1|FID) + Sex*Age + (1|Plate_NO), glycans_raw_omfo)
fit <- lmer(IgG4_A2G ~ (1|FID) + Sex*Age + (1|Plate_NO), glycans_raw_omfo,
            control = lmerControl(optimizer = "nlminbwrap"))
allfits <- allFit(fit)
isOK <- sapply(allfits,is,"merMod")
lapply(allfits[isOK],function(x) x@optinfo$conv$lme4$messages)

```


###### V2: plate as fixed effect

Number of batch levels is sufficient:

See section "Should I treat factor xxx as fixed or random?" in https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html

"For practical purposes, there must be a reasonable number of random-effects levels (e.g. blocks) – more than 5 or 6 at a minimum. This is not surprising if you consider that random effects estimation is trying to estimate an among-block variance"

*advantage* Groups are no longer non-nested (there is only one random variable), in the sense of Gelman2007, p244 ("overlapping categories"). This implies that HLMdiag *CAN* be used.

*But problem:* No more shrinkage of batch effect -> potential overfitting -> loss of information in residuals. E.g. ComBat uses empirical Bayes to avoid such over-correction, which is particularly important when some batches are small. [@nygaardMethodsThatRemove2016]

Other potential issue: LME does not deal with fact that some families are MZ, others are DZ. Distribution on FID effects is probably not pure gaussiam, but rather a mixture of a MZ and a DZ distribution with different mean family effects and potentially also different variance of the family effects.



```{r glycan-lmer-plate-fixed, eval=FALSE}

# ENI1H5N4F0S1 has only the singularity problem.
glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age + Plate_NO,
                    glycans_raw_omfo %>% 
                      dplyr::mutate_at(.vars = vars(FID,IID,Plate_NO, Sex), as.factor)
                    )
```

Completely solves the singularity problem + reduces number of non-convergence warnings to 1 (LAGY_A2B). This is further resolved by using a different optimizer.

```{r glycan-lmer-plate-fixed-testcase, eval=FALSE}
fit <- lmer(LAGY_A2B ~ (1|FID) + Sex*Age + Plate_NO, glycans_raw, 
            control = lmerControl(optimizer = "nlminbwrap"))
```


###### compare new to old residuals

```{r glycan-lmer-plate-fixedVSrandom, eval=FALSE}

res_comp <- dplyr::bind_cols(
  tidyr::gather(glycans_fam_adj, glycan, new_res),
  tidyr::gather(glycans_fam_adj_old, glycan, old_res)
)

p_res <- ggplot(res_comp, aes(x=old_res, y=new_res))+
  geom_point(alpha=0.1)+
  theme_bw()

ggsave(filename = "residuals_wgcna_mixed-vs-fixed-plateNO.png", plot = p_res, path =figdir)

summary(abs(res_comp$old_res - res_comp$new_res), na.rm=TRUE)
summary(res_comp$new_res)

par(mfrow=c(1,2))
boxplot(abs(res_comp$old_res - res_comp$new_res), na.rm=TRUE)
boxplot(res_comp$new_res)

```

###### Model diagnostics



##### Immunophenotypes

```{r quantile-normalisation}



```


### Cross-Modality

Batch effects of lesser relevance.

# WGCNA

Objective of WGCNA is not necessarily globally optimal partitioning, but rather detection of meaningful modules. Grey module is allowed to be very heterogeneous. Also, scale-free property is mostly a heuristic to downscale noise via the power transform, rather than based on theoretical arguments from network/graph theory. Ref Peter Langfelder, Bioconductor forum, https://support.bioconductor.org/p/66101/ [24/04/2019].

How to deal with "grey" module?

Current approach:
- treat as other clusters, but ignore module-specific modularity contribution in calculation of global modularity?
- Equivalently: treat all grey members as singleton clusters (so that in modularity calculation: delta(C_i,C_j)=0 for every singleton cluster i and every cluster j)

But also included full modularity, treating the grey cluster as a real cluster.

Modularity is calculated for based on three similarity matrices:
  - correlation (following Gomez2009, with known limitations cf MacMahon2015).
  - adjacency ~ network parameters
  - TOM ~ network parameters

## Glycans

### Including derived traits

#### Correlation distribution

```{r}
glycans_qn_fam_adj_cor <- WGCNA::cor(glycans_qn_fam_adj, 
                                     method = "pearson",
                                     use="pairwise.complete.obs")
glycans_raw_cor <- WGCNA::cor(glycans_raw_omfo, 
                              method = "pearson",
                              use="pairwise.complete.obs")
hist(unlist(glycans_qn_fam_adj_cor))
hist(unlist(glycans_raw_cor))
hist(abs(unlist(glycans_qn_fam_adj_cor))^2)
```



#### Power parameter

```{r glycans-scale-free-softpower}

cowplot::plot_grid(
glycans_scale_free$p_rsq,
glycans_scale_free$p_k
)
#low rsq with power distribution (scale free topology): because not independent entities but related measurements?
```

#### Network module parameters


```{r glycans-parameter-exploration, include=FALSE}


# object.size(glycan_module_stats) %>% format(units="MB")
# saveRDS(glycan_module_stats, file = glue("{datadir}/glycan_module_stats.RDS"))
# glycan_module_stats <- readRDS(glue("{datadir}/glycan_module_stats.RDS"))
# View(glycan_module_stats$color_overview)

#scale module-wise modularities?
# glycan_module_stats$plots[[6]]
glycan_module_stats$merge_pars_used %>% 
  map_depth(2,as_tibble) %>%
  map(
    ~bind_cols(.x) %>% 
      setnames(paste0("cut", 1:length(.x))) %>% 
      mutate(parameter=rownames(.x[[1]])) %>% 
      dplyr::select(parameter, everything())
  )
# glycan_module_stats$mod_modularities


# calculate total non-grey modularity, based on weights in adj or in TOM, but with module definition always based on TOM
# remark: sometimes adj-based module definition might be better 
#TODO: retrieve ref for remark


```

#### Networks

```{r glycans-parameter-exploration-plots}
for (i in seq_along(glycan_module_stats$plots)){
  draw(glycan_module_stats$plots[[i]], column_title = glue("Network {i}"))
}

```

Modularity:

```{r}
glycan_module_stats$modularity_overview %>% 
  unite(col="nw_cut", network_iter, cut_iter) %>% 
  dplyr::select(nw_cut:cor_mod_modularities_incl_grey) %>% 
  tidyr::gather(mod_def, mod_value, -nw_cut) %>% 
  ggplot(aes(x=mod_def, y=mod_value, color=nw_cut, group=nw_cut))+
  geom_line()+
  coord_flip()

glycan_module_stats$modularity_overview %>% 
  # unite(col="nw_cut", network_iter, cut_iter) %>% 
  # dplyr::select(cor_mod_modularities_incl_grey) %>% 
  mutate_at(vars(adj_mod_modularities_no_grey:cor_mod_modularities_incl_grey),
            function(x){(x-min(x))/diff(range(x))}) %>% 
  tidyr::gather(mod_def, scaled_mod_value, adj_mod_modularities_no_grey:cor_mod_modularities_incl_grey) %>%
  dplyr::filter(str_detect(mod_def, "no_grey")) %>% 
  ggplot(aes(x=mod_def, y=scaled_mod_value, color=cut_iter, group=cut_iter))+
  geom_line()+
  facet_grid(networktype~softpower+corfnc)+
  coord_flip()
```


In IgA:

- In HYT (IgA - Ser89-126): three blocks with strong positive intra-block and negative inter-block correlations:

    - H>3, high S
    - H>3, low S
    - H < 5

- cluster of "Bisection of diantennary structures" for different sites, and some of the raw glycans contributing to the derived trait at those

In IgG:

- IgGI low fucose, low SA cluster


### Excluding derived traits

#### power parameter

```{r glycans-scale-free-softpower-noderiv}

# View(glycans_scale_free$sft_df)
cowplot::plot_grid(
  glycans_scale_free_noderiv$p_rsq,
  glycans_scale_free_noderiv$p_k
)
#low rsq with power distribution (scale free topology): because not independent entities but related measurements?
```

#### Network module parameters

```{r glycans-parameter-exploration-noderiv, include=FALSE}


#scale module-wise modularities?
# glycan_module_stats$plots[[6]]
glycan_module_stats_noderiv$merge_pars_used%>% 
    map_depth(2,as_tibble) %>%
  map(
    ~bind_cols(.x) %>% 
      setnames(paste0("cut", 1:length(.x))) %>% 
      mutate(parameter=rownames(.x[[1]])) %>% 
      dplyr::select(parameter, everything())
  )
# calculate total non-grey modularity, based on weights in adj or in TOM, but with module definition always based on TOM
# remark: sometimes adj-based module definition might be better 
#TODO: retrieve ref for remark


```

#### Networks

```{r glycans-parameter-exploration-noderiv-plots}
for (i in seq_along(glycan_module_stats_noderiv$plots)){
  draw(glycan_module_stats_noderiv$plots[[i]], column_title = glue("Network {i}"))
}
```

Modularity:

```{r}
glycan_module_stats_noderiv$modularity_overview 
```

```{r}
glycan_module_stats_noderiv$modularity_overview %>% 
  unite(col="nw_cut", network_iter, cut_iter) %>% 
  dplyr::select(nw_cut:cor_mod_modularities_incl_grey) %>% 
  tidyr::gather(mod_def, mod_value, -nw_cut) %>% 
  ggplot(aes(x=mod_def, y=mod_value, color=nw_cut, group=nw_cut))+
  geom_line()+
  coord_flip()

glycan_module_stats_noderiv$modularity_overview %>% 
  # unite(col="nw_cut", network_iter, cut_iter) %>% 
  # dplyr::select(cor_mod_modularities_incl_grey) %>% 
  mutate_at(vars(adj_mod_modularities_no_grey:cor_mod_modularities_incl_grey),
            function(x){(x-min(x))/diff(range(x))}) %>% 
  tidyr::gather(mod_def, scaled_mod_value, adj_mod_modularities_no_grey:cor_mod_modularities_incl_grey) %>%
  dplyr::filter(str_detect(mod_def, "no_grey")) %>% 
  ggplot(aes(x=mod_def, y=scaled_mod_value, color=cut_iter, group=cut_iter))+
  geom_line()+
  facet_grid(networktype~softpower+corfnc)+
  coord_flip()
```


Compared to WGCNA including derivered traits:

Optimal set parameter set is the same (network 2, iteration 3), with slightly higher maximal modularity in the network excluding derived traits.

In IgA:

* In HYT (IgA - Ser89-126): *recovered* three blocks with strong positive intra-block and negative inter-block correlations:

    + H>3, high S
    + H>3, low S
    + H < 5

* cluster of "Bisection of diantennary structures" for different sites, and some of the raw glycans contributing to the derived trait at those sites: *not retrieved*

In IgG:

* IgGI low fucose, low SA cluster *is recovered*

### General remarks

Negative correlations can carry important information, especially when the glycans are separated by addition/removal of a single sugar moiety.

To assure this

  1) Structure of the glycan would need to be known
  2) Biological evidence of the reaction, e.g. compiled in database such as KEGG?
  
  But: sialic acid typically terminal -> excellent candidate

Examples: 
ENI1H5N4F0S1 and ENI1H5N4F0S2 are strongly negatively correlated.
LAGY1H5N4F0S2 and LAGY1H5N4F0S1 are strongly positively correlated.

Could relate to:

* regulation of reaction: constitutive versus induced?
* opposite associations with IPs?

Some derived traits might be driven primarily by a single glycan. Example: ENI_A2S and ENI1H5N4F0S2

-> Possible to assess 'relevance' of derived traits by variance decomposition?

## Immunophenotypes

```{r wgcna-ip-memory-calc}
# https://peterlangfelder.com/2018/11/25/blockwise-network-analysis-of-large-data/

mem_needed <- function(n_feat){
  bytes <-n_feat^2*8*3
  gigabytes <- bytes/2^(10*3)
  gigabytes
}

max_block_size <- function(GB_RAM){
  bytes <- GB_RAM*2^(10*3)
  n_feat <- sqrt(bytes/24)
  n_feat
}

n_good_ips <- length(good_ips)
n_ips <- ncol(ips)-2
mem_needed(n_good_ips)  #33 GB
mem_needed(n_ips)  #180 GB

max_block_size(32)

```

# Session info

```{r session_info, include=TRUE, echo=TRUE, results='markup'}
devtools::session_info()
```


# References




