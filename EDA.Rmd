---
title: "IgX glycosylation - immunophenotype analysis"
author: 
  - name: "Simon Couvreur"
output: 
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    code_folding: hide
    number_sections: true
    self_contained: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}

if (interactive()){
  library(tidyverse)
  library(data.table)
  library(lattice)
  # library(cowplot)
  library(ggforce)
  library(gridExtra)
  library(ComplexHeatmap)
  library(WGCNA)
  library(lme4)
  library(EnvStats)
  library(naniar)
  library(glue)
  library(igraph)
  library(citr)
  library(GGally)
  library(sjPlot)
  library(here)
  library(knitr)
  library(drake)
  library(caret)
}

figdir <- here("results/figures")
resultdir <- here("results")
cluster_pars_dir <- here("WGCNA_parameters")
datadir <- here("data")

knitr::opts_chunk$set(echo = TRUE,    # in combination with code_folding: hide
                      dev=c("png", "pdf"),
                      fig.path = here("results/figures/report/"))
# automatically switch .png to .pdf in knitr::include_graphics, when rendering to PDF
# https://bookdown.org/yihui/bookdown/figures.html
options(knitr.graphics.auto_pdf = TRUE) 


```

```{r functions-source}
# see make.R
# otherwise: self-invalidation, see ?make
```


```{r functions-local}


# 
# tryCatch.W.E_original <- function(expr)
# {
#   W <- NULL
#   w.handler <- function(w){ # warning handler
#     W <<- w
#     invokeRestart("muffleWarning")
#   }
#   # M <- NULL
#   # m.handler <- function(m){ # warning handler
#   #   M <<- m
#   #   # invokeRestart("muffleWarning")
#   # }
#   list(value = withCallingHandlers(tryCatch(expr, error = function(e) e),
#                                    warning = w.handler),
#        warning = W)
# }

# str(tryCatch.W.E(warning("hi")))

```




# Preprocessing

## Load data

Note 618 (13455158 - 13454540) lines were removed, which is more than the 604 mentioned by Alessia.

```{r remove-error-lines}
# 
# f <- file(here("input_data/glycans_20190409_immunopheno_corrected.tsv.gz"), open="r")
# o <- file(here("input_data/glycans_20190409_immunopheno_corrected_cleanedSimon.tsv.gz"), open = "a")
# i <- 1
# 
# while (TRUE){
#   if (i%%100000==0)
#     print(i)
#   
#   line <- readLines(f, n=1)
#   if(str_count(line, "\t")==16){
#     writeLines(text=line, con=o)
#   }
#   i <- i+1
# }
```


```{r read-data}

# glycans
glycans <- readd(glycans)
glycans_raw <- readd(glycans_raw)

glycans_mf <- readd(glycans_mf)
glycans_raw_mf <- readd(glycans_raw_mf)

# IPs
ips <- readd(ips)
ips_raw <- readd(ips_raw)

# overlap
overlap_samples <- readd(overlap_samples)
overlap_samples_raw <- readd(overlap_samples_raw)


# mean abundances
ip_raw_mean <- readd(ip_raw_mean)

# IP missingness
ip_raw_missing <- readd(ip_raw_missing)
ip_missing <- readd(ip_missing)

#Popante output
ip_igx_univar <- readd(ip_igx_univar)


# annotations
ip_anno <- readd(ip_anno)
ip_anno_dt <- data.table(ip_anno)
IgA_anno_names_raw <- readd(IgA_anno_names_raw)
IgA_anno_names_derived <- readd(IgA_anno_names_derived)
twin_fam <-readd(twin_fam)

```

## data preprocessing

```{r QC-filter}

ip_igx_univar_good <- readd(ip_igx_univar_good)

good_ips <- ip_anno$set_name[ip_anno$robust_mario_qc == "Good"] %>% na.omit()
ips_qc <- ips %>%
  dplyr::select(!!good_ips)

```

# Quality control

p-value QQ-plot:

```{r univar-qq}

knitr::include_graphics(here::here("results/figures/univar_qqplot.png"))

```



# Data exploration

## Sample overlap

409 participants in intersection of glycans and immunophenotypes. All analyses are restricted to these samples.

```{r}
venn <- venn.diagram(list(ips = ips$IID, igx = glycans$IID), filename = NULL)
grid.draw(venn)
```

Two participants are in intersection of the raw, but not in the corrected glycans and immunophenotypes.

```{r}
setdiff(overlap_samples_raw, overlap_samples)
```


## Glycans

### IgX features

#### Missingness

##### Missing samples per feature

Visual overview, raw glycan data. (Observations clustered and features sorted)

```{r glycan-raw-vis-miss}
naniar::vis_miss(glycans_raw_o, cluster=TRUE, sort_miss = TRUE)+
  coord_flip()
```

Visual overview, corrected glycan data. (Observations clustered and features sorted)

```{r glycan-corr-vis-miss}
naniar::vis_miss(glycans_o, cluster=TRUE, sort_miss = TRUE)+
  coord_flip()
```

Histogram of proportion missing samples per feature:

```{r hist-miss-samples-per-feat}
par(mfrow=c(1,2))
hist(colMeans(is.na(glycans_o[-(1:5)])), 15, main = "glycans - corrected", xlab = "proportion missing")
hist(colMeans(is.na(glycans_raw_o[-(1:5)])), 15,  main = "glycans - raw", xlab = "proportion missing")

```

In both raw and corrected glycans, 3 features with >20% missingness were dropped.

corrected glycans:

```{r excluded-igx-feat-corr}
glycan_feat_drop <- glycans_o[,-(1:5)] %>%
  dplyr::summarise_all(~mean(is.na(.))) %>% 
  tidyr::gather(feature, prop_missing) %>%
  dplyr::filter(prop_missing > 0.2) %>%
  dplyr::arrange(desc(prop_missing))

glycan_feat_drop

```

Raw glycans:

```{r excluded-igx-feat-raw}

glycan_feat_drop_raw <- glycans_raw_o[,-(1:5)] %>%
  dplyr::summarise_all(~mean(is.na(.))) %>% 
  tidyr::gather(feature, prop_missing) %>%
  dplyr::filter(prop_missing > 0.2) %>%
  dplyr::arrange(desc(prop_missing))

glycan_feat_drop_raw

```

##### Missing features per sample (after filtering features)

Visual overview, raw glycan data. (Observations clustered and features sorted)

```{r glycan-raw-vis-miss-2}
naniar::vis_miss(dplyr::select(glycans_raw_o[-(1:5)], -!!glycan_feat_drop$feature), cluster=TRUE, sort_miss = TRUE)+
  coord_flip()

```

Visual overview, corrected glycan data. (Observations clustered and features sorted)

```{r glycan-corr-vis-miss-2}
naniar::vis_miss(dplyr::select(glycans_o[-(1:5)], -!!glycan_feat_drop$feature), cluster=TRUE, sort_miss = TRUE)+
  coord_flip()

```

Histogram of percentage missing features per sample:

```{r hist-miss-feat-per-sample}
par(mfrow=c(1,2))
hist(rowMeans(is.na(dplyr::select(glycans_o[-(1:5)], -!!glycan_feat_drop$feature))), 25, main = "glycans - corrected")
hist(rowMeans(is.na(dplyr::select(glycans_raw_o[-(1:5)], -!!glycan_feat_drop$feature))), 25, main = "glycans - corrected")

```

Complete samples:

corrected glycans: `r sum(rowMeans(is.na(glycans_o[-(1:5)]))==0)`
raw glycans: `r sum(rowMeans(is.na(glycans_raw_o[-(1:5)]))==0)`

In both raw and corrected glycans, 3 samples with > 60% missingness were filtered out:

corrected glycans:

```{r excluded-samples-corr}

glycans_o[,-(1:5)] %>%
  as.matrix() %>% 
  t() %>%
  # structure(., colnames = as.character(glycans[,2])) %>%
  as_tibble() %>% 
  set_names(as.character(glycans_o[[2]])) %>%
  dplyr::summarise_all(~mean(is.na(.))) %>% 
  tidyr::gather(IID, prop_missing) %>%
  dplyr::filter(prop_missing > 0.6) %>%
  dplyr::arrange(desc(prop_missing))

```

Raw glycans:

```{r excluded-sample-raw}

glycans_raw_o[,-(1:5)] %>%
  as.matrix() %>% 
  t() %>%
  # structure(., colnames = as.character(glycans[,2])) %>%
  as_tibble() %>% 
  set_names(as.character(glycans_raw_o[[2]])) %>%
  dplyr::summarise_all(~mean(is.na(.))) %>% 
  tidyr::gather(IID, prop_missing) %>%
  dplyr::filter(prop_missing > 0.6) %>%
  dplyr::arrange(desc(prop_missing))

```


##### Imputation

###### KNN-impute

mostly for PCA.

parameters to tune: distance metric [@troyanskayaMissingValueEstimation2001a] and [@malinowskiClassificationPatientsTreated2015]

```{r kkn-impute, include=FALSE, eval=FALSE}

mat <- as.matrix(glycans_mf[,-(1:5)])
n_iter <- 100
k_range <- 3:10
rmse <- matrix(0, ncol = length(k_range), nrow = n_iter)
complete_mask <- !is.na(mat)
set_na_prop <- 0.1



# using samples with NA among k neighbours != "classical imputation" [@berettaNearestNeighborImputation2016]
# https://stats.stackexchange.com/questions/223613/caret-preprocess-knnimpute-error-more-nearest-neighbours-than-there-are-points

my_knn <- function(mat, dist_method = "euclidean"){
  stopifnot(is.matrix(mat))
  # imputes column-wise, i.e. finds nearest columns to column to be imputed
  imp <- mat
  incomplete_col <- which(colSums(is.na(mat)) > 0)
  for (j in seq_along(incomplete_col)){
    avail_rows <- which(!is.na(mat[,j]))
    dist_m <- do.call(dist, list(x=mat, method=dist_method)) #
  }
}


for (i in 1:n_iter){
  set_NA_ind <- sample(which(complete_mask), set_na_prop*prod(dim(mat)))
  mat_setNA <- mat
  mat_setNA[set_NA_ind] <- NA
  for (k in k_range){
    cat("mataset", i, "; k = ", k)
    imp_vim <- kNN(mat_setNA, k=k)
    yai <- yai()
    imp_yai <- 
    rmse[i, k] <- sqrt(sum((imp[set_NA_ind] - mat[set_NA_ind])^2))
  }
}
boxplot(rmse)

m <- matrix(sample(c(TRUE, FALSE),20, replace = TRUE), ncol=2)
m
which(m) #column-wise
m[which(m)] <- 5
m

m <- matrix(rep(1:3, each=3), ncol = 3)
m <- matrix(rep(1:3, 3), ncol = 3)
dist(m)
```


#### Glycome-wide differences between samples

Limited variation in per-sample sums.

```{r}
boxplot(apply(glycans_raw[,-(1:5)], 1, sum))

#coef. var  = 1.6%
sd(apply(glycans_raw[,-(1:5)], 1, sum), na.rm = TRUE)/mean(apply(glycans_raw[,-(1:5)], 1, sum), na.rm = TRUE)
sd(apply(glycans_raw[,-(1:5)], 1, mean), na.rm = TRUE)/mean(apply(glycans_raw[,-(1:5)], 1, mean), na.rm = TRUE)

```


see notes 30/04

###### regularised iterative PCA imputation (integrated imputation and PCA)

problem: missing data. proportion missing=

```{r}
mean(is.na(glycans_raw_mf[,-(1:5)]))
```

solution: regularised iterative PCA, cf Josse2016, Josse2012

```{r PCA-impute}
glycan_ncomp <- estim_ncpPCA(glycans_raw_mf[,-(1:5)], ncp.max = 15, ncp.min = 0, scale=TRUE,
                      verbose=TRUE)


glycan_imp <- imputePCA(
  glycans_raw_mf[,-(1:5)], 
  ncp=ncomp$ncp, 
)

imp_glycans_raw_mf <- cbind(glycans_raw_mf[, 'Plate_NO'], imp$completeObs)

# PCA plots as here: http://juliejosse.com/wp-content/uploads/2018/05/DataAnalysisMissingR.html

head(glycans_raw_pca$eig,10)

glycans_raw_pca <- PCA(imp_glycans_raw_mf, 
    ncp=ncomp$ncp,
    quali.sup = 1,
    graph = FALSE)

# % variance explained
head(glycans_raw_pca$eig,10)

```

Biplot, colored by plate_NO shows no strong clustering by plate in first 2 PCs (but limited % variance explained)

```{r}

plot(glycans_raw_pca, habillage = 1, lab = "quali")

```


Boxplots per plate

```{r}

#32 plates x 15 PCs
summarise(glycans_raw_mf, n_distinct(Plate_NO))


glycans_raw_pca$ind$coord %>%
  cbind(glycans_raw_mf[, 'Plate_NO']) %>%
  tidyr::gather(PC, value, -Plate_NO) %>% 
  dplyr::mutate(PC = factor(PC, levels = paste0("Dim.", 1:15))) %>% 
  ggplot(aes(x=as.factor(Plate_NO), y=value))+
  geom_boxplot()+
  facet_grid(PC~.)+
  coord_flip()

```

Hierarchical clustering

```{r}

boxplot(apply(imp_glycans_raw_mf[,-1], 1, sum))

d <- dist(glycans_raw[,-(1:5)], method = "euclidean")
hc <- hclust(d, method = "average")

# debug NA in dist
d.na <- is.na(d)
d.m <- as.matrix(d)

head(which(is.na(d.m), arr.ind = TRUE))
dist(bind_rows(glycans_raw[1,-(1:5)], glycans_raw[35,-(1:5)]))
all(is.na(glycans_raw[1,-(1:5)]) | is.na(glycans_raw[35,-(1:5)]))


```


### Feature annotations

#### IgA

99 IgA features (input==results)

- 71 raw
- 28 derived

But in annotations:

- 75 raw
- 52 derived

When examining set diffs (see sheet 'overview'):

- 29 raw anno names not in inputs/results
    - 6 peptide clusters
    - 13 LAGCa/b
    - 10 reason unclear
- 25 input/results names not in raw anno names (29-25=75-71)
    - reason unclear for all
- Out of 28 derived input/results names and 52 derived anno names, only 6 are overlapping


IgA features in (corrected) glycans and PopPAnTe output are equal sets.

```{r}
# in univariate results
IgA_names_univar <- unique(ip_igx_univar_good$response) %>% .[!str_detect(., pattern = "IgG")]

# in corrected glycan data
IgA_names_input <- names(glycans)[-(1:5)]  %>% .[!str_detect(., pattern = "IgG")]

# n_input == n_results
setequal(IgA_names_univar, IgA_names_input)

# split in raw and derived
IgA_names_univar_raw <- IgA_names_univar[1:71]
IgA_names_univar_derived <- IgA_names_univar[72:99]
```


For raw features:

in anno but not in univar:

```{r}
# annotated names not in input/results -------

#raw
# note: in input/results raw names are coded as e.g. HYT1H2N5F0S2 while in anno they are HYT_H2N5F0S2
setdiff(IgA_anno_names_raw$feature %>% str_replace("_","1"), IgA_names_univar_raw) %T>% 
  writeLines(., glue("{resultdir}/anno_raw_noresult.txt"))
```

in univar but not in anno:

```{r}
setdiff(IgA_names_univar_raw, IgA_anno_names_raw$feature %>% str_replace("_","1")) %T>% 
  writeLines(.,glue("{resultdir}/result_raw_no_anno.txt"))
```


For derived features:

in anno but not in univar:

```{r}
#derived
# note: derived names have same coding in all sets
setdiff(IgA_anno_names_derived$feature, IgA_names_univar_derived)
```

in univar but not in anno:

```{r}
setdiff(IgA_names_univar_derived, IgA_anno_names_derived$feature)
```

```{r}
intersect(IgA_names_univar_derived, IgA_anno_names_derived$feature)
length(union(IgA_names_univar_derived, IgA_anno_names_derived$feature))

```


#### IgG

52 IgG features, but no annotation?

### Marginal distributions (after correction for age*SEX + (1|batch))

see PDF


## Immunophenotypes

### Compare raw vs corrected

IIDs 99611 and 99612 (rows 225 and 226) have been dropped in the corrected IPs.

```{r}
dim(ips)
dim(ips_raw)

setdiff(ips_raw$IID, ips$IID)
which(ips_raw$IID %in% setdiff(ips_raw$IID, ips$IID))

```


### Feature annotations

#### Structure of dataset (feature hierarchy)

Overview resolved issues:

* 'xxx.new' in set_name column -> all have source=="P6 newB"
* duplicated subset_names?

Overview open issues:

* "(Ignore)" in canonical_name_x column -> meaning?
* lineage "04-Aug" -> meaning? + inconsistent coding in subset_name column ("4-8")
* lower-level parent lineages -> mean_value =100% -> where as proportion of higher-level (i.e. containing) lineage?

##### Parent lineage

Cell counts are expressed as proportion of a "parent lineage", this is part before '/' in the subset_name column and also the value in the 'lineage' column (when source is not Lin or MFI). Exception is lineage "04-Aug", which is encoded in the subset_name column as 4-8.

```{r}
before_slash <- str_match(ip_anno$subset_name[ip_anno$source != "Lin" & ip_anno$source != "MFI"], pattern = "(.*)/[^/]+")[,2]
not_eq <- which(before_slash != ip_anno$lineage[ip_anno$source != "Lin" & ip_anno$source != "MFI"])
View(ip_anno[ip_anno$source != "Lin" & ip_anno$source != "MFI",] %>% .[not_eq,])
before_slash[not_eq]

```

The 44 parent lineages are:

```{r}
ip_anno_dt[phenotype=="*", .(set_name, trait, source, lineage, subset_name, mean_value)][order(lineage)]
# View("parent_lineages")
```

The parent_lineages can be (any of):

* contained within a different parent_lineage: only memory vs naive in CD4 and CD8
* expressed as % of a containing lineage in the source=="Lin" lines: e.g. parent_lineage "4-8-" in "%NKT:4-8-".


```{r}
ip_anno_dt[source=="Lin", .(set_name, trait, source, lineage, subset_name, mean_value)][order(subset_name)] 
# View("source==Lin")

```

While parent_lineage CD4/Memory is contained within parent_lineage CD4, CD4/Memory is not explicitly listed among any of the subsets of CD4.

Without clear definition of which marker values define the Memory subset of CD4, the proportion CD4:CD4/Memory cannot be obtained.

More generally, if a measurement is expressed as proportion of a parent_lineage, and the parent_lineage is not a) expressed  explicitly as a fraction of its containing parent_lineage (in subset_name column), or b) listed among source==Lin lines, the proportion of the measurement relative to higher-order lineages cannot be calculated.

```{r}
ip_anno_dt[subset_name == "CD4/Memory/"]
ip_anno_dt[subset_name == "CD4/Memory"]
ip_anno_dt[subset_name == "CD4/"]
ip_anno_dt[str_detect(subset_name, pattern="CD4:.*")]

ip_anno_dt[str_detect(subset_name, pattern="CD4/[^/]*$") & source != "Lin" & source != "MFI"] %>% 
  mutate(n_marker = str_count(phenotype, pattern="\\-|\\+")) %>% arrange(n_marker) %>% View()

```

Example: Parent lineage "mDC/1c-/16-" can be traced as "%mDC:1c-" -> "%Lin-14-:mDC" -> "%Lin-:14-" -> "%Lin-" in the source==Lin lines, but the proportion "mDC/1c-:16-" is missing from the source==Lin lines, nor is it explicitly expressed elsewhere in the data.

```{r}

ip_anno_dt[str_detect(subset_name, pattern="mDC/1c-/[^/]*$") & source != "Lin" & source != "MFI"] %>% 
  mutate(n_marker = str_count(phenotype, pattern="\\-|\\+")) %>% arrange(n_marker) %>% View()

ip_anno_dt[str_detect(subset_name, pattern="mDC/1c-") & source != "Lin" & source != "MFI"] %>% 
  mutate(n_marker = str_count(phenotype, pattern="\\-|\\+")) %>% arrange(n_marker) %>% View()

```

##### duplicated subset_names

All correspond to subsets which are measured on multiple plates, typically at a high-level of the gating hierarchy (where the lower gates are different between plates). This occurs for CD4, CD8, DPT and DNT

For CD4 & CD8: only the subsets on later plate(s) are labeled as (Ignore)
For DPT & DNT: all subsets are labeled as (Ignore)

Some of the duplicated subsets are parent lineages (where mean_value = 100%), therefore cell count is not relevant. For the others: mean values could be used instead of ignoring one?

```{r}
table(ip_anno$source)

sum(duplicated(ip_anno$subset_name))
ip_anno[which(duplicated(ip_anno$subset_name)|duplicated(ip_anno$subset_name, fromLast = TRUE)),] %>% View()

```

##### (Ignore) labels in canonical_name_x

43,474 IPs have the (Ignore) label.

```{r}
str_match(ip_anno$canonical_name_x, pattern=".*\\(Ignore\\).*") %>% na.omit(.) %>% View()
```


Does not correspond clearly with the QC columns (neither Max nor Mario).

```{r}

table(ignore=str_detect(ip_anno$canonical_name_x, pattern=".*\\(Ignore\\).*"), 
      max_qc=ip_anno$final_qc_max)
table(ignore=str_detect(ip_anno$canonical_name_x, pattern=".*\\(Ignore\\).*"), 
      mario_qc=ip_anno$robust_mario_qc)

```

Cannot be related to duplication, because much fewer duplicates than (Ignore) labels

```{r}
table(ignore=str_detect(ip_anno$canonical_name_x, pattern=".*\\(Ignore\\).*"),
      duplicated=duplicated(ip_anno$subset_name)|duplicated(ip_anno$subset_name, fromLast = TRUE))
```


Meaning remains unclear, currently the (Ignore) label is not taken into account.

#### *.new in set_name

Strictly used for source=="P6 newB". 

```{r}
# str_match(ip_anno$set_name, pattern=".*new.*") %>% na.omit(.) %>% View()

table(str_detect(ip_anno$set_name, pattern=".*new.*"), ip_anno$source)
```

Moreover, these subsets make up the large majority (95%) of Panel 6 (P6) subsets.

```{r}
table(ip_anno$source)

mean(str_detect(ip_anno_dt[str_detect(source, pattern = "P6"), set_name], pattern=".*new.*"))
```


#### Missingness in annotation fields

Note: empty fields in immunophenotype annotation set to NA.

No annotation column has more than 20% missing data.

```{r ip_anno_missingness}
# which(is.na(ip_anno$lineage))
stopifnot(sum(ip_anno$lineage ==""))

gg_miss_var(ip_anno, show_pct = TRUE)

```

Moreover, the annotation columns relevant to this analysis are either free of missing data, or (for phenotype and lineage) can be complete traced down to the lines where source=="MFI" or source =="Lin".

```{r}
ip_anno_dt[, table(source, phenotype_NA = is.na(phenotype))]
ip_anno_dt[, table(source, lineage_NA = is.na(lineage))]

```

The 2 QC columns do have some NAs (coded as NA in the flat file), but are not used in this analysis (yet).
NAs occur in the same rows in both QC columns, and exclusively for "P6" and "P6 earlyB", but not for the most frequent "P6 newB".

Presumably Panel 6 was rerun and no QC was performed on the first run because of some clear defect?

```{r}
all(which(is.na(ip_anno$final_qc_max))==which(is.na(ip_anno$robust_mario_qc)))

ip_anno_dt[, table(source, final_QC_NA = is.na(final_qc_max))]

```


#### Define overall grouping of IPs,

To accomodate lineage, MFI and other CSFs, introduce 'composite_lin_source':

- for lineage/MFI features: 'Source' column (value = 'Lin' or 'MFI')
- 'Lineage' column for all others (value=parent lineage on which the subset is calculated)

```{r composite_lin_source_count}
count(ip_anno, composite_lin_source) %>% 
  arrange(desc(n))
  # View()
  
```

### Features (immunophenotypes)

#### Missingness

Histogram of proportion missing samples per feature:

```{r}
par(mfrow=c(1,2))
boxplot(ip_missing$missing_prop)
abline(h = 0.2, col = "red")
boxplot(ip_raw_missing$missing_prop)
abline(h = 0.2, col = "red")
# ggplot(ip_missing, aes(x="",y=missing_prop))+
#   geom_boxplot()
# plot(ecdf(ip_missing$missing_prop))

```

Per-feature proportion missing is maintained between the raw and corrected datasets (maximally around 1% difference).

```{r}
setkey(ip_missing, set_name)
setkey(ip_raw_missing, set_name)
merge(ip_raw_missing, ip_missing, all=FALSE, suffixes = c("_raw", "_corrected"))[
  , .(diff_perc=abs(missing_prop_raw - missing_prop_corrected)/pmin(missing_prop_raw, missing_prop_corrected)*100)
][order(-diff_perc)]

```

In both raw and corrected IPs, 59 features with >20% missingness were dropped.

corrected IPs:

```{r excluded-ip-feat-corr}
ip_missing[missing_prop > 0.2,][ip_anno_dt, .(set_name, subset_name, missing_prop),on="set_name", nomatch=0][order(-missing_prop)]
  
```

Raw IPs:

```{r excluded-ip-feat-raw}
ip_raw_missing[missing_prop > 0.2,][ip_anno_dt, .(set_name, subset_name, missing_prop),on="set_name", nomatch=0][order(-missing_prop)]

```


#### Low frequency IPs

##### Replicate strategy Roederer2015

From Roederer2015:

"more than one third were eliminated from analyses as they represented subset frequencies that were too low for robust analysis (less than 0.1% of the parental ‘‘lineage’’ gate)." (Fig S4)

and 

"First, we eliminated those CSFs whose mean frequency (within their parent ‘‘lineage’’) was below 0.1% or above 99%" (section "Selection of Subsets for Heritability and GWAS Analysis", p S2)

First attempt: calculate per-IP total signal over samples, and express as proportion of per-lineage (column 'lineage' in ip_anno) sum of per-IP totals

But problem:'tri-boolean' gates are partially overlapping -> parent lineage signal < sum(contained signals)

```{r low-freq-ips}
# data.table for speed
# by taking mean (rather than sum) per feature, downstream analysis is not affected by per-feature proportion missing

# join in lineage info
# https://stackoverflow.com/questions/30944116/r-data-table-subgroup-weighted-percent-of-group
setkey(ip_raw_mean, set_name)
setkey(ip_anno_dt, set_name)
ip_raw_mean[ip_anno_dt[source != "Lin" & source != "MFI",.(set_name, lineage)], 
            nomatch=0][
              , 
              .(mean_sign = mean_signal, 
                  tot_lin_signal = sum(mean_signal),
                  prop = mean_signal/sum(mean_signal)),
              by=lineage
              ]

```


New approach: treat relative cell counts 'as-is'. The two quotes above differ in whether subsets above 99% are also discarded or not.

```{r low-freq-ips2}
ip_raw_mean[, table(mean_signal < 1e-3 | mean_signal >0.99)]
ip_raw_mean[, table(mean_signal < 1e-3)]
ip_raw_mean[, table(mean_signal >0.99)]

```

Only a small proportion of subsets are below 0.1% relative frequency. In contrast, with the criterion of excluding both low and high relative frequency subsets (as in Roederer2015, section "Selection of Subsets for Heritability and GWAS Analysis"), the proportion of subsets which fit this definition (42%) is roughly similar to Roederer2015 (37%).

```{r}

mean(ip_raw_mean[,mean_signal < 1e-3 | mean_signal >0.99])

# Roederer2015
1-49928/78683
```

##### IP frequency distribution

```{r ip-freq-distr}

ip_raw_mean[order(-mean_signal)]

boxplot(ip_raw_mean[, mean_signal])


```



#### Marginal distributions (after correction for age + (1|batch))

see PDF for subset of IPs


## Batch effects

No batch information for IPs, only for glycans

### Experimental design glycans



```{r exp-design}
design <- glycans_raw[,1:5] %>%
  dplyr::left_join(twin_fam, by=c("FID"="Family_No", "IID"="STUDY_NO", "Sex"="SEX"))

ggplot(design, aes(x=factor(Plate_NO), fill=ETHNICITY))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(design, aes(x=factor(Plate_NO), fill=ACTUAL_ZYGOSITY))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(design, aes(x=factor(Plate_NO), fill=Sex))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(design, aes(x=factor(Plate_NO), y=Age))+
  geom_boxplot()+
  stat_n_text()

```

IPs only obtained on female participants:

```{r}

glycans_raw %>% 
  dplyr::filter(IID %in% ips_raw$IID) %>% 
  count(Sex)

```

Therefore re-check confounding with batch effect in experimental design, restricted to samples overlapping between glycans and ips.

```{r exp-design-overlap}

design_overlap <- glycans_raw[,1:5] %>%
  dplyr::left_join(twin_fam, by=c("FID"="Family_No", "IID"="STUDY_NO", "Sex"="SEX")) %>% 
  dplyr::filter(IID %in% ips_raw$IID) 

ggplot(design_overlap, aes(x=factor(Plate_NO), fill=ETHNICITY))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(design_overlap, aes(x=factor(Plate_NO), fill=ACTUAL_ZYGOSITY))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(design_overlap, aes(x=factor(Plate_NO), fill=Sex))+
  geom_bar(position = "fill")+
  ylab("proportion")
ggplot(design_overlap, aes(x=factor(Plate_NO), y=Age))+
  geom_boxplot()+
  stat_n_text()

```

Only zygosity shows between-plate

### Quantile normalisation

Quantile normalisation (applied to both 'corrected' datasets as pre-processing step in PopPAnTe).

* Main assumption/impact: forces the distribution of signals (over probes/glycans/FACS) to be identical in each sample
    + Thus removes global differences between samples, i.e. global upregulation will not be detectable
    
```{r}
s <- svd(glycans[-(1:5)])

```

### PCA glycans




# Analysis of univariate results

## Number of significant associations ~ FDR threshold

```{r n-sign-ass-FDR}
plot(ecdf(ip_igx_univar_good$pv_adj_global),
     xlab = "FDR",
     ylab = "prop associations < FDR")

ip_igx_univar_good %>%
  summarise(n_FDR20 = sum(pv_adj_global <0.2),
            n_FDR10 = sum(pv_adj_global <0.1),
            n_FDR5 = sum(pv_adj_global <0.05),
            n_FDR1 = sum(pv_adj_global <0.01))

ecdf_abs <- function(x){
  e <- ecdf(x)
  function(t){e(t)*length(x)}
}
ecdf_logabs <- function(x){
  e <- ecdf(x)
  function(t){log10(e(t)*length(x))}
}

fdr20_ecdf <- ecdf_abs(ip_igx_univar_good$pv_adj_global %>% .[. < 0.2])
plot(fdr20_ecdf, xlim = c(0,0.2),
     xlab = "FDR",
     ylab = "n associations < FDR")

fdr_ecdf <- ecdf_abs(ip_igx_univar_good$pv_adj_global)
plot(fdr_ecdf,
     xlab = "FDR",
     ylab = "n associations < FDR")

fdr_log_ecdf <- ecdf_logabs(ip_igx_univar_good$pv_adj_global)
plot(fdr_log_ecdf,
     xlab = "FDR",
     ylab = "log10(n associations < FDR)")

```

## Number of significantly associated features per omic ~ FDR threshold


```{r n-sign-ass-features-FDR}

n_associated_m <- readd(n_associated_m)

ggplot(ungroup(n_associated_m), aes(x=fdr_threshold, y=prop, colour=omic))+
  geom_line()+
  theme_bw()+
  # facet_zoom(x = fdr_threshold < 0.25)
  facet_zoom(xlim = c(0,0.2))+
  xlab("FDR threshold")+
  ylab("proportion of features with association < FDR")

```


## Explore top associations



```{r top-associations}
ip_igx_univar_good_anno <- readd(ip_igx_univar_good_anno)


# arrange(ip_igx_univar_good_anno, pvalue) %>% dplyr::select(response, IgX, predictor, composite_lin_source, pvalue) %>% head(100)

# ip_igx_univar_good_anno %>%
#   head(10000) %>% 
#   count(IgX, composite_lin_source)%>%
#   arrange(IgX, desc(n)) 
  # View()


```


### Top asssociations scatter
see PDF

### Enrichment of subgroups

#### At 5% FDR level

##### IP subgroup enrichment - overall

```{r ip-enrich-overall}

ip_lin_source_enrich_overall <- ip_igx_univar_good_anno %>%
  dplyr::filter(pv_adj_global < 0.05) %>%
  count(composite_lin_source) %>%
  left_join(count(ip_anno, composite_lin_source),
            by = "composite_lin_source", 
            suffix = c("_assoc", "_feat")) %>% 
  mutate(`n_assoc/n_feat` = n_assoc/n_feat,
         `prop(n_assoc)` = n_assoc/sum(n_assoc)
         # `prop(n_assoc/n_feat)` = `n_assoc/n_feat`/sum(`n_assoc/n_feat`)
         ) %>% 
  dplyr::select(composite_lin_source, n_assoc, n_feat, `n_assoc/n_feat`, everything()) %>% 
  arrange(desc(`n_assoc/n_feat`))

ip_lin_source_enrich_overall
write_csv(ip_lin_source_enrich_overall, path = glue("{resultdir}/ip_lin_source_enrich_overall.csv"))

```

##### IP subgroup enrichment - by IgX

```{r ip-enrich-byIgX}

ip_lin_source_enrich_byIgX <- ip_igx_univar_good_anno %>%
  dplyr::filter(pv_adj_global < 0.05) %>%
  count(composite_lin_source, IgX) %>%
  left_join(count(ip_anno, composite_lin_source),
            by = "composite_lin_source", 
            suffix = c("_assoc", "_feat")) %>% 
  group_by(IgX) %>% 
  mutate(`n_assoc/n_feat` = n_assoc/n_feat,
         `prop(n_assoc)` = n_assoc/sum(n_assoc)
         # `prop(n_assoc/n_feat)` = `n_assoc/n_feat`/sum(`n_assoc/n_feat`)
         ) %>% 
  dplyr::select( IgX,composite_lin_source, n_assoc, n_feat, `n_assoc/n_feat`, everything()) %>% 
  arrange(IgX, desc(`n_assoc/n_feat`))

ip_lin_source_enrich_byIgX
write_csv(ip_lin_source_enrich_byIgX, path = glue("{resultdir}/ip_lin_source_enrich_byIgX.csv"))


```


#### continuous ~ FDR

##### IgX subgroup enrichment

```{r glycan-IgG-enrich_cont}

# running_IgG_perc <- c()
# for (i in 1:nrow(ip_igx_univar_good)){
#   running_IgG_perc <- head(ip_igx_univar_good$response, i) %>% str_detect(., pattern = "IgG") %>% mean(.)
# }

running_IgG_perc <-  readd(running_IgG_perc)

p_IgG_enrich <- tibble(cum_IgG_perc = running_IgG_perc,
                       index = 1:length(running_IgG_perc)) %>% 
  .[c(1:10000,seq(10000,length(running_IgG_perc), 100)),] %>%
  ggplot(aes(x=index,y=cum_IgG_perc))+
  geom_line()+
  scale_x_log10()

## gssave not require once Rmd becomes easily renderable
# ggsave(p_IgG_enrich, filename = glue("{figdir}/p_IgG_enrich.png"),
#        width = 6, height = 6, dpi = 600)

p_IgG_enrich

```

##### IP subgroup enrichment

Overall:

```{r ip-lin_source-enrich_cont}

lin_source_props_df <- readd(lin_source_props_df)

p_lin_source_enrich <- lin_source_props_df %>%
  tidyr::gather(lin_source, prop, -one_of("top","weighting")) %>%
  ggplot(aes(x=top, y=prop, color=lin_source, group=lin_source))+
  geom_line()+
  scale_x_log10()+
  facet_wrap(weighting~.)
# ggsave(p_lin_source_enrich, filename = glue("{figdir}/p_lin_source_enrich.png"),
#        width = 6, height = 6, dpi = 600)

p_lin_source_enrich

```

By IgX:

```{r lin_source-enrich-by-IgX_cont}

lin_source_IgX_props_df <- readd(lin_source_IgX_props_df)

# plot
p_lin_source_IgX_enrich <- lin_source_IgX_props_df %>%
  tidyr::gather(lin_source, prop, -one_of(c("top", "IgX"))) %>%
  ggplot(aes(x=top, y=prop, color=lin_source, group=lin_source))+
  geom_line()+
  scale_x_log10()+
  facet_grid(IgX~.)
# ggsave(p_lin_source_IgX_enrich, filename = glue("{figdir}/p_lin_source_IgX_enrich.png"),
#        width = 6, height = 6, dpi = 600)

p_lin_source_IgX_enrich

```



# Correlation structures


## Family clustering

### Options to deal with family clustering

* work with residuals of linear mixed effect model
    - problem MZ&DZ treated the same
    - kinship2::kinship + coxme::lmekin 
        +for historical remarks about the libraries see https://cran.r-project.org/web/packages/coxme/vignettes/lmekin.pdf
* explicitly model family structure to calculate correlations
* use PopPAnTe? IF variables in regression are on same scale, correlation coefficient = regression coefficient (https://en.wikipedia.org/wiki/Simple_linear_regression#Fitting_the_regression_line)
    + links to question of quantile-normalisation (see above, batch effects)

### bivariate multi-level model

#### Literature on estimation of bivariate correlation from clustered/multi-level/hierarchical samples

Problem statement: for each sample two or more variables are observed, but samples are correlated (here, due to being twins).

unanswered SO on same subject: https://stats.stackexchange.com/questions/81220/multivariate-mixed-model-in-nlme

Extra catch: would need to re-implement/by-pass first phases of WGCNA, because these only take raw data, not pre-computed correlations


*Excellent ref:*

Luo, J., D’Angelo, G., Gao, F., Ding, J., Xiong, C., 2015. Bivariate correlation coefficients in family-type clustered studies. Biometrical Journal 57, 1084–1109. https://doi.org/10.1002/bimj.201400131

- three type of correlations, "unconditional marginal bivariate correlation coefficient" is what is needed.

*But how to implement?*

From following refs it seems that only within-cluster BCC is estimable with lme4.

However, the model of Luo2015 is also implemented on melted data! (see their appendix)

method via melting the data (multivariate -> repeated measures) in lme4
https://mac-theobio.github.io/QMEE/MultivariateMixed.html#a-trick-to-do-multivariate-mixed-models-using-lme4
http://rpubs.com/bbolker/3336
https://stackoverflow.com/questions/7831243/multivariate-linear-mixed-model-in-lme4



Other refs:
Lorenz, D.J., Datta, S., Harkema, S.J., 2011. Marginal association measures for clustered data. Stat Med 30, 3181–3191. https://doi.org/10.1002/sim.4368
Bland, J.M., Altman, D.G., 1995a. Statistics notes: Calculating correlation coefficients with repeated observations: Part 1—correlation within subjects. BMJ 310, 446. https://doi.org/10.1136/bmj.310.6977.446
Bland, J.M., Altman, D.G., 1995b. Calculating correlation coefficients with repeated observations: Part 2—correlation between subjects. BMJ 310, 633. https://doi.org/10.1136/bmj.310.6980.633
Meinck, S., Rodriguez, M.C., 2013. Considerations for correlation analysis using clustered data: working with the teacher education and development study in mathematics (TEDS-M) and other international studies. Large-scale Assessments in Education 1, 7. https://doi.org/10.1186/2196-0739-1-7
Rosner, B., Glynn, R.J., 2017. Estimation of rank correlation for clustered data. Statistics in Medicine 36, 2163–2186. https://doi.org/10.1002/sim.7257
Rosner, R., 2016. Marginal Association Measures for Clustered Data.

### correlation of LME residuals

#### LMM assumptions



#### Within-modality

##### Glycans

###### V1: plate as mixed effect

Groups are non-nested, in the sense of Gelman2007, p244 ("overlapping categories"). This implies that HLMdiag *cannot* be used.

```{r glycan-lmer-plate-random, eval=FALSE}

glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age + (1|Plate_NO),
                    glycans_raw %>% 
                      dplyr::mutate_at(.vars = vars(FID,IID,Plate_NO, Sex), as.factor)
                    )

# gives boundary fit (see ?isSingular)


# adjust all glycans
glycans_fam_adj_l <- list()
fits <- warns <- msgs <- list()
for (i in 6:ncol(glycans_raw)){
  
  # debug
  # i <- 7
  
  igx <- names(glycans_raw)[i]
  model_data <- cbind(glycans_raw[,1:5],
                      structure(glycans_raw[, ..i], names="glycan")) %>%
    dplyr::mutate_at(.vars = vars(FID,IID,Plate_NO, Sex), as.factor)
  tmp <- tryCatch.W.E(
    lmer(glycan ~ (1|FID) + (1|Plate_NO) + Sex*Age, model_data)
    )
  fits[[igx]] <- tmp$value
  warns[[igx]] <- tmp$warning
  msgs[[igx]] <- tmp$message
  
  glycans_fam_adj_l[[igx]] <- residuals(fits[[igx]])
}


glycans_fam_adj_old <-glycans_fam_adj_l %>%
  purrr::map(~tibble(res=.x, index=names(.x)) %>%
        dplyr::right_join(tibble(index=as.character(1:nrow(glycans_raw))), by="index") %>%
        dplyr::select(res)) %>%
  dplyr::bind_cols() %>%
  rlang::set_names(names(glycans_fam_adj_l))



```


###### Troubleshoot

####### Problem outline

Problems:

* isSingular message for 80/151 glycans
* convergence warning for 10/151 glycans


Troubleshoot resources:
FAQ at https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html
  (sections "Convergence warnings" and "Singular models)
  
Convergence resources:
 * ?convergence
 * lme4 convergence warnings: troubleshooting at https://rstudio-pubs-static.s3.amazonaws.com/33653_57fc7b8e5d484c909b615d8633c01d51.html
 
 Singularity resources:
 * https://stats.stackexchange.com/questions/378939/dealing-with-singular-fit-in-mixed-models


```{r glycan-lmer-plate-random-troubleshoot, eval=FALSE}
# reason for boundary fit: not that FID and plate are strictly aliased
dplyr::summarise_all(glycans_raw[,1:4],n_distinct)
glycans_raw %>%
  dplyr::group_by(FID) %>%
  dplyr::summarise(n_plates = n_distinct(Plate_NO)) %>%
  dplyr::count(n_plates)
# rather it seems that plate_NO is generating the warnings
glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|Plate_NO), glycans_raw)  # not ok
summary(glycans_fit)   # var(plate_NO)=0
glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age, glycans_raw)  # ok


## co-occurrence pattern of singularity messages and convergence warnings

# var(plate_no) is non-zero for 63% of glycans
plate_var <- fits %>%
  purrr::map(~broom::tidy(.x)) %>%
  purrr::map(~dplyr::filter(.x, term=="sd_(Intercept).Plate_NO")) %>%
  purrr::map_dbl("estimate")

boxplot(plate_var)
mean(plate_var==0)
plate_var_overview <- tibble(glycan=names(plate_var),
       plate_var=plate_var,
       msg = (glycan %in% names(msgs)),
       warn = (glycan %in% names(warns)))
# View(plate_var_overview)
# for isSingular message, there is a clear trend with plate_var
# for non-convergence warning, there does not seem to be such trend
plate_var_overview %>%
  tidyr::gather(output_type, value, -one_of("glycan", "plate_var")) %>%
  ggplot(aes(x=value, y=plate_var))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~output_type)+
  stat_n_text()


```


####### Try different optimizers (allFit), following ?convergence

IgG4_A2G has only the convergence problem.


```{r glycan-lmer-plate-random-allfit, eval=FALSE}
fit <- lmer(IgG4_A2G ~ (1|FID) + Sex*Age + (1|Plate_NO), glycans_raw)
fit <- lmer(IgG4_A2G ~ (1|FID) + Sex*Age + (1|Plate_NO), glycans_raw,
            control = lmerControl(optimizer = "nlminbwrap"))
allfits <- allFit(fit)
isOK <- sapply(allfits,is,"merMod")
lapply(allfits[isOK],function(x) x@optinfo$conv$lme4$messages)

```


###### V2: plate as fixed effect

Number of batch levels is sufficient:

See section "Should I treat factor xxx as fixed or random?" in https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html

"For practical purposes, there must be a reasonable number of random-effects levels (e.g. blocks) – more than 5 or 6 at a minimum. This is not surprising if you consider that random effects estimation is trying to estimate an among-block variance"

*advantage* Groups are no longer non-nested (there is only one random variable), in the sense of Gelman2007, p244 ("overlapping categories"). This implies that HLMdiag *CAN* be used.

*But problem:* No more shrinkage of batch effect -> potential overfitting -> loss of information in residuals. E.g. ComBat uses empirical Bayes to avoid such over-correction, which is particularly important when some batches are small. [@nygaardMethodsThatRemove2016]

Other potential issue: LME does not deal with fact that some families are MZ, others are DZ. Distribution on FID effects is probably not pure gaussiam, but rather a mixture of a MZ and a DZ distribution with different mean family effects and potentially also different variance of the family effects.



```{r glycan-lmer-plate-fixed, eval=FALSE}

# ENI1H5N4F0S1 has only the singularity problem.
glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age + Plate_NO,
                    glycans_raw %>% 
                      dplyr::mutate_at(.vars = vars(FID,IID,Plate_NO, Sex), as.factor)
                    )

glycans_fam_adj <- readd(glycans_fam_adj)
```

Completely solves the singularity problem + reduces number of non-convergence warnings to 1 (LAGY_A2B). This is further resolved by using a different optimizer.

```{r glycan-lmer-plate-fixed-testcase, eval=FALSE}
fit <- lmer(LAGY_A2B ~ (1|FID) + Sex*Age + Plate_NO, glycans_raw, 
            control = lmerControl(optimizer = "nlminbwrap"))
```


###### compare new to old residuals

```{r glycan-lmer-plate-fixedVSrandom, eval=FALSE}

res_comp <- dplyr::bind_cols(
  tidyr::gather(glycans_fam_adj, glycan, new_res),
  tidyr::gather(glycans_fam_adj_old, glycan, old_res)
)

p_res <- ggplot(res_comp, aes(x=old_res, y=new_res))+
  geom_point(alpha=0.1)+
  theme_bw()

ggsave(filename = "residuals_wgcna_mixed-vs-fixed-plateNO.png", plot = p_res, path =figdir)

summary(abs(res_comp$old_res - res_comp$new_res), na.rm=TRUE)
summary(res_comp$new_res)

par(mfrow=c(1,2))
boxplot(abs(res_comp$old_res - res_comp$new_res), na.rm=TRUE)
boxplot(res_comp$new_res)

```

###### Model diagnostics

```{r}

vis_miss(glycans_fam_adj)
glycans_fam_adj



```




##### Immunophenotypes

### Cross-Modality

#### Glycans

```{r glycans}

# hist(glycan_cor[upper.tri(glycan_cor, diag = TRUE)])
# ComplexHeatmap::Heatmap(glycan_cor)


```

#### Immunophenotypes

```{r ips}

# # validate bigcor function on glycans
# testbigcor <- bigcor(x=as.data.frame(glycans[,-(1:6)]), nblocks = 10, use = "pairwise.complete.obs", method = "pearson")
# dim.ff(testbigcor) <- c(150*150,1)
# ffbase::hist.ff(testbigcor, breaks = 50)
# 
# # now apply to ips
# ips[,-(1:2)]
```


# WGCNA

Objective of WGCNA is not necessarily globally optimal partitioning, but rather detection of meaningful modules. Grey module is allowed to be very heterogeneous. Also, scale-free property is mostly a heuristic to downscale noise via the power transform, rather than based on theoretical arguments from network/graph theory. Ref Peter Langfelder, Bioconductor forum, https://support.bioconductor.org/p/66101/ [24/04/2019].

How to deal with "grey" module?

- treat as other clusters, but ignore module-specific modularity contribution in calculation of global modularity?  <- current approach
- all grey members as singleton clusters?


Modularity based on similarity, adjacency or TOM? Different choice depending on whether modules defined based on adj or TOM?


## Glycans

### Including derived traits

```{r glycans-scale-free-softpower}
glycans_scale_free <- readd(glycans_scale_free)
# View(glycans_scale_free$sft_df)
glycans_scale_free$p_rsq
glycans_scale_free$p_k

#low rsq with power distribution (scale free topology): because not independent entities but related measurements?
```




```{r glycans-parameter-exploration, include=FALSE}

glycan_module_stats <- readd(glycan_module_stats)

# object.size(glycan_module_stats) %>% format(units="MB")
# saveRDS(glycan_module_stats, file = glue("{datadir}/glycan_module_stats.RDS"))
# glycan_module_stats <- readRDS(glue("{datadir}/glycan_module_stats.RDS"))
# View(glycan_module_stats$color_overview)

#scale module-wise modularities?
glycan_module_stats$plots[[6]]
glycan_module_stats$merge_pars_used
glycan_module_stats$mod_modularities

# calculate total non-grey modularity, based on weights in adj or in TOM, but with module definition always based on TOM
# remark: sometimes adj-based module definition might be better 
#TODO: retrieve ref for remark


```

Networks:
```{r glycans-parameter-exploration-plots}
for (i in seq_along(glycan_module_stats$plots)){
  draw(glycan_module_stats$plots[[i]], column_title = glue("Network {i}"))
}

```


In IgA:

- In HYT (IgA - Ser89-126): three blocks with strong positive intra-block and negative inter-block correlations:

    - H>3, high S
    - H>3, low S
    - H < 5

- cluster of "Bisection of diantennary structures" for different sites, and some of the raw glycans contributing to the derived trait at those

In IgG:

- IgGI low fucose, low SA cluster


### Excluding derived traits


```{r glycans-scale-free-softpower-noderiv}
glycans_scale_free_noderiv <- readd(glycans_scale_free_noderiv)
# View(glycans_scale_free$sft_df)

glycans_scale_free_noderiv$p_rsq
glycans_scale_free_noderiv$p_k

#low rsq with power distribution (scale free topology): because not independent entities but related measurements?
```


```{r glycans-parameter-exploration-noderiv, include=FALSE}

glycan_module_stats_noderiv <- readd(glycan_module_stats_noderiv)

#scale module-wise modularities?
glycan_module_stats$plots[[6]]
glycan_module_stats$merge_pars_used
glycan_module_stats$mod_modularities

# calculate total non-grey modularity, based on weights in adj or in TOM, but with module definition always based on TOM
# remark: sometimes adj-based module definition might be better 
#TODO: retrieve ref for remark


```

Networks:

```{r glycans-parameter-exploration-noderiv-plots}
for (i in seq_along(glycan_module_stats$plots)){
  draw(glycan_module_stats$plots[[i]], column_title = glue("Network {i}"))
}
```


Compared to WGCNA including derivered traits:

Optimal set parameter set is the same (network 2, iteration 3), with slightly higher maximal modularity in the network excluding derived traits.

In IgA:

* In HYT (IgA - Ser89-126): *recovered* three blocks with strong positive intra-block and negative inter-block correlations:

    + H>3, high S
    + H>3, low S
    + H < 5

* cluster of "Bisection of diantennary structures" for different sites, and some of the raw glycans contributing to the derived trait at those sites: *not retrieved*

In IgG:

* IgGI low fucose, low SA cluster *is recovered*

### General remarks

Negative correlations can carry important information, especially when the glycans are separated by addition/removal of a single sugar moiety.

To assure this

  1) Structure of the glycan would need to be known
  2) Biological evidence of the reaction, e.g. compiled in database such as KEGG?
  
  But: sialic acid typically terminal -> excellent candidate

Examples: 
ENI1H5N4F0S1 and ENI1H5N4F0S2 are strongly negatively correlated.
LAGY1H5N4F0S2 and LAGY1H5N4F0S1 are strongly positively correlated.

Could relate to:

* regulation of reaction: constitutive versus induced?
* opposite associations with IPs?

Some derived traits might be driven primarily by a single glycan. Example: ENI_A2S and ENI1H5N4F0S2

-> Possible to assess 'relevance' of derived traits by variance decomposition?



## immunophenotypes

```{r wgcna-ip-memory-calc}
# https://peterlangfelder.com/2018/11/25/blockwise-network-analysis-of-large-data/

mem_needed <- function(n_feat){
  bytes <-n_feat^2*8*3
  gigabytes <- bytes/2^(10*3)
  gigabytes
}

max_block_size <- function(GB_RAM){
  bytes <- GB_RAM*2^(10*3)
  n_feat <- sqrt(bytes/24)
  n_feat
}

n_good_ips <- length(good_ips)
n_ips <- ncol(ips)-2
mem_needed(n_good_ips)  #33 GB
mem_needed(n_ips)  #180 GB

max_block_size(64)

```



    

    



# References {#references .unnumbered}




