---
title: "IgX glycosylation - immunophenotype analysis"
author: 
  - name: "Simon Couvreur"
  
output: 
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    code_folding: hide
    number_sections: true
    self_contained: yes
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(tidyverse)
library(data.table)
library(lattice)
# library(cowplot)
library(ggforce)
library(gridExtra)
library(ComplexHeatmap)
library(WGCNA)
library(lme4)
library(EnvStats)
library(naniar)
library(glue)
library(igraph)
library(citr)
library(GGally)
library(sjPlot)
library(here)
library(knitr)

figdir <- here("results/figures")
resultdir <- here("results")
cluster_pars_dir <- here("WGCNA_parameters")
datadir <- here("data")

knitr::opts_chunk$set(echo = FALSE,
                      dev=c("png", "pdf"),
                      fig.path = here("results/figures/report/"))


```

```{r functions-source}
# see make.R
# otherwise: self-invalidation, see ?make
```


```{r functions-local}


# 
# tryCatch.W.E_original <- function(expr)
# {
#   W <- NULL
#   w.handler <- function(w){ # warning handler
#     W <<- w
#     invokeRestart("muffleWarning")
#   }
#   # M <- NULL
#   # m.handler <- function(m){ # warning handler
#   #   M <<- m
#   #   # invokeRestart("muffleWarning")
#   # }
#   list(value = withCallingHandlers(tryCatch(expr, error = function(e) e),
#                                    warning = w.handler),
#        warning = W)
# }

# str(tryCatch.W.E(warning("hi")))

```




# Preprocessing

Note 618 (13455158 - 13454540) lines were removed, which is more than the 604 mentioned by Alessia.

```{r remove-error-lines}
# 
# f <- file(here("input_data/glycans_20190409_immunopheno_corrected.tsv.gz"), open="r")
# o <- file(here("input_data/glycans_20190409_immunopheno_corrected_cleanedSimon.tsv.gz"), open = "a")
# i <- 1
# 
# while (TRUE){
#   if (i%%100000==0)
#     print(i)
#   
#   line <- readLines(f, n=1)
#   if(str_count(line, "\t")==16){
#     writeLines(text=line, con=o)
#   }
#   i <- i+1
# }
```


```{r read-data}

# glycans
glycans <- readd(glycans)
glycans_raw <- readd(glycans_raw)

# IPs
ips <- readd(ips)
ips_raw <- readd(ips_raw)

#Popante output
ip_igx_univar <- readd(ip_igx_univar)


# annotations
ip_anno <- readd(ip_anno)
IgA_anno_names_raw <- readd(IgA_anno_names_raw)
IgA_anno_names_derived <- readd(IgA_anno_names_derived)
twin_fam <-readd(twin_fam)

```

## data preprocessing

```{r QC-filter}

ip_igx_univar_good <- readd(ip_igx_univar_good)

good_ips <- ip_anno$set_name[ip_anno$robust_mario_qc == "Good"] %>% na.omit()
ips_qc <- ips %>%
  dplyr::select(!!good_ips)

```


# Quality control

drake issue: including images can be problematic. Since they are not located in the code chunks/inline code, there is no dependency being generated?

p-value QQ-plot:






```{r missing-data}

# `r sprintf("![](%s)", glue("{figdir}/univar_qqplot.png")`

naniar::vis_miss(glycans_raw)

```


# Data exploration

## IgX features

### Annotations

99 IgA features (input==results)

- 71 raw
- 28 derived

But in annotations:

- 75 raw
- 52 derived

When examining set diffs (see sheet 'overview'):

- 29 raw anno names not in inputs/results
    - 6 peptide clusters
    - 13 LAGCa/b
    - 10 reason unclear
- 25 input/results names not in raw anno names (29-25=75-71)
    - reason unclear for all
- Out of 28 derived input/results names and 52 derived anno names, only 6 are overlapping


52 IgG features, but no annotation?



```{r IgA-glycan-features-anno}

# in univariate results
IgA_names_univar <- unique(ip_igx_univar_good$response) %>% .[!str_detect(., pattern = "IgG")]

# in corrected glycan data
IgA_names_input <- names(glycans)[-(1:5)]  %>% .[!str_detect(., pattern = "IgG")]

# n_input == n_results
setequal(IgA_names_univar, IgA_names_input)

# split in raw and derived
IgA_names_univar_raw <- IgA_names_univar[1:71]
IgA_names_univar_derived <- IgA_names_univar[72:99]


# annotated names not in input/results -------

#raw
# note: in input/results raw names are coded as e.g. HYT1H2N5F0S2 while in anno they are HYT_H2N5F0S2
setdiff(IgA_anno_names_raw$feature %>% str_replace("_","1"), IgA_names_univar_raw) %>% 
  writeLines(., glue("{resultdir}/anno_raw_noresult.txt"))
setdiff(IgA_names_univar_raw, IgA_anno_names_raw$feature %>% str_replace("_","1")) %>% 
  writeLines(.,glue("{resultdir}/result_raw_no_anno.txt"))

#derived
# note: derived names have same coding in all sets
setdiff(IgA_anno_names_derived$feature, IgA_names_univar_derived)
setdiff(IgA_names_univar_derived, IgA_anno_names_derived$feature)
intersect(IgA_names_univar_derived, IgA_anno_names_derived$feature)
length(union(IgA_names_univar_derived, IgA_anno_names_derived$feature))

```

### Marginal distributions

see PDF


## IP features

### Compare raw vs corrected

IIDs 99611 and 99612 (rows 225 and 226) have been dropped in the corrected IPs.

```{r}
dim(ips)
dim(ips_raw)

setdiff(ips_raw$IID, ips$IID)
which(ips_raw$IID %in% setdiff(ips_raw$IID, ips$IID))

```


### Missingness of annotation fields

```{r ip_anno_missingness}
gg_miss_var(ip_anno, show_pct = TRUE)
```

### Find higher grouping of IPs

'composite_lin_source':

- for lineage/MFI features: 'Source' column (value = 'Lin' or 'MFI')
- 'Lineage' for all others (value=lineage on which the subset is calculated)

```{r composite_lin_source_count}
count(ip_anno, composite_lin_source) %>% 
  arrange(desc(n))
  # View()
  
```

### Marginal distributions

see PDF for subset of IPs

# Analysis of univariate results

## Number of significant associations ~ FDR threshold

```{r n-sign-ass-FDR}
plot(ecdf(ip_igx_univar_good$pv_adj_global),
     xlab = "FDR",
     ylab = "prop associations < FDR")

ip_igx_univar_good %>%
  summarise(n_FDR20 = sum(pv_adj_global <0.2),
            n_FDR10 = sum(pv_adj_global <0.1),
            n_FDR5 = sum(pv_adj_global <0.05),
            n_FDR1 = sum(pv_adj_global <0.01))

ecdf_abs <- function(x){
  e <- ecdf(x)
  function(t){e(t)*length(x)}
}
ecdf_logabs <- function(x){
  e <- ecdf(x)
  function(t){log10(e(t)*length(x))}
}

fdr20_ecdf <- ecdf_abs(ip_igx_univar_good$pv_adj_global %>% .[. < 0.2])
plot(fdr20_ecdf, xlim = c(0,0.2),
     xlab = "FDR",
     ylab = "n associations < FDR")

fdr_ecdf <- ecdf_abs(ip_igx_univar_good$pv_adj_global)
plot(fdr_ecdf,
     xlab = "FDR",
     ylab = "n associations < FDR")

fdr_log_ecdf <- ecdf_logabs(ip_igx_univar_good$pv_adj_global)
plot(fdr_log_ecdf,
     xlab = "FDR",
     ylab = "log10(n associations < FDR)")

```

## Number of significantly associated features per omic ~ FDR threshold


```{r n-sign-ass-features-FDR}

n_associated_m <- readd(n_associated_m)

ggplot(ungroup(n_associated_m), aes(x=fdr_threshold, y=prop, colour=omic))+
  geom_line()+
  theme_bw()+
  # facet_zoom(x = fdr_threshold < 0.25)
  facet_zoom(xlim = c(0,0.2))+
  xlab("FDR threshold")+
  ylab("proportion of features with association < FDR")

```


## Explore top associations

```{r top-associations}
ip_igx_univar_good_anno <- readd(ip_igx_univar_good_anno)


arrange(ip_igx_univar_good_anno, pvalue) %>% dplyr::select(response, IgX, predictor, composite_lin_source, pvalue) %>% head(100)

ip_igx_univar_good_anno %>%
  head(10000) %>% 
  count(IgX, composite_lin_source)%>%
  arrange(IgX, desc(n)) 
  # View()


```


### Top asssociations scatter
see PDF

### Enrichment of subgroups

#### At 5% FDR level

##### IP subgroup enrichment - overall

```{r ip-enrich-overall}

ip_lin_source_enrich_overall <- ip_igx_univar_good_anno %>%
  dplyr::filter(pv_adj_global < 0.05) %>%
  count(composite_lin_source) %>%
  left_join(count(ip_anno, composite_lin_source),
            by = "composite_lin_source", 
            suffix = c("_assoc", "_feat")) %>% 
  mutate(`n_assoc/n_feat` = n_assoc/n_feat,
         `prop(n_assoc)` = n_assoc/sum(n_assoc)
         # `prop(n_assoc/n_feat)` = `n_assoc/n_feat`/sum(`n_assoc/n_feat`)
         ) %>% 
  dplyr::select(composite_lin_source, n_assoc, n_feat, `n_assoc/n_feat`, everything()) %>% 
  arrange(desc(`n_assoc/n_feat`))
write_csv(ip_lin_source_enrich_overall, path = glue("{resultdir}/ip_lin_source_enrich_overall.csv"))

```

##### IP subgroup enrichment - by IgX

```{r ip-enrich-byIgX}

ip_lin_source_enrich_byIgX <- ip_igx_univar_good_anno %>%
  dplyr::filter(pv_adj_global < 0.05) %>%
  count(composite_lin_source, IgX) %>%
  left_join(count(ip_anno, composite_lin_source),
            by = "composite_lin_source", 
            suffix = c("_assoc", "_feat")) %>% 
  group_by(IgX) %>% 
  mutate(`n_assoc/n_feat` = n_assoc/n_feat,
         `prop(n_assoc)` = n_assoc/sum(n_assoc)
         # `prop(n_assoc/n_feat)` = `n_assoc/n_feat`/sum(`n_assoc/n_feat`)
         ) %>% 
  dplyr::select( IgX,composite_lin_source, n_assoc, n_feat, `n_assoc/n_feat`, everything()) %>% 
  arrange(IgX, desc(`n_assoc/n_feat`))
write_csv(ip_lin_source_enrich_byIgX, path = glue("{resultdir}/ip_lin_source_enrich_byIgX.csv"))


```



#### continuous ~ FDR

##### IgX subgroup enrichment

```{r glycan-IgG-enrich_cont}

# running_IgG_perc <- c()
# for (i in 1:nrow(ip_igx_univar_good)){
#   running_IgG_perc <- head(ip_igx_univar_good$response, i) %>% str_detect(., pattern = "IgG") %>% mean(.)
# }

running_IgG_perc <-  readd(running_IgG_perc)

p_IgG_enrich <- tibble(cum_IgG_perc = running_IgG_perc,
                       index = 1:length(running_IgG_perc)) %>% 
  .[c(1:10000,seq(10000,length(running_IgG_perc), 100)),] %>%
  ggplot(aes(x=index,y=cum_IgG_perc))+
  geom_line()+
  scale_x_log10()

## gssave not require once Rmd becomes easily renderable
# ggsave(p_IgG_enrich, filename = glue("{figdir}/p_IgG_enrich.png"),
#        width = 6, height = 6, dpi = 600)

```

##### Lin-source enrichment

Overall:

```{r ip-lin_source-enrich_cont}

lin_source_props_df <- readd(lin_source_props_df)

p_lin_source_enrich <- lin_source_props_df %>%
  tidyr::gather(lin_source, prop, -one_of("top","weighting")) %>%
  ggplot(aes(x=top, y=prop, color=lin_source, group=lin_source))+
  geom_line()+
  scale_x_log10()+
  facet_wrap(weighting~.)
# ggsave(p_lin_source_enrich, filename = glue("{figdir}/p_lin_source_enrich.png"),
#        width = 6, height = 6, dpi = 600)


```

By IgX:

```{r lin_source-enrich-by-IgX_cont}

lin_source_IgX_props_df <- readd(lin_source_IgX_props_df)

# plot
p_lin_source_IgX_enrich <- lin_source_IgX_props_df %>%
  tidyr::gather(lin_source, prop, -one_of(c("top", "IgX"))) %>%
  ggplot(aes(x=top, y=prop, color=lin_source, group=lin_source))+
  geom_line()+
  scale_x_log10()+
  facet_grid(IgX~.)
# ggsave(p_lin_source_IgX_enrich, filename = glue("{figdir}/p_lin_source_IgX_enrich.png"),
#        width = 6, height = 6, dpi = 600)


```



# Correlation structures

Non-trivial due to family clustering, either:

    - work with residuals of linear mixed effect model
    - explicitly model family structure to calculate correlations
    - use PopPAnTe? IF variables in regression are on same scale, correlation coefficient = regression coefficient (https://en.wikipedia.org/wiki/Simple_linear_regression#Fitting_the_regression_line)
        - links to question of quantile-normalisation

## family-adjusted correlations

### Literature on estimation of bivariate correlation from clustered/multi-level/hierarchical samples

Problem statement: for each sample two or more variables are observed, but samples are correlated (here, due to being twins).

unanswered SO on same subject: https://stats.stackexchange.com/questions/81220/multivariate-mixed-model-in-nlme

Extra catch: would need to re-implement first phases of WGCNA, because these only take raw data, not pre-computed correlations


*Excellent ref:*

Luo, J., D’Angelo, G., Gao, F., Ding, J., Xiong, C., 2015. Bivariate correlation coefficients in family-type clustered studies. Biometrical Journal 57, 1084–1109. https://doi.org/10.1002/bimj.201400131

- three type of correlations, "unconditional marginal bivariate correlation coefficient" is what is needed.

*But how to implement?*


From following refs it seems that only within-cluster BCC is estimable with lme4.

However, the models of Luo2015 is also implemented on melted data! (see their appendix)

method via melting the data (multivariate -> repeated measures) in lme4
https://mac-theobio.github.io/QMEE/MultivariateMixed.html#a-trick-to-do-multivariate-mixed-models-using-lme4
http://rpubs.com/bbolker/3336
https://stackoverflow.com/questions/7831243/multivariate-linear-mixed-model-in-lme4



Other refs:
Lorenz, D.J., Datta, S., Harkema, S.J., 2011. Marginal association measures for clustered data. Stat Med 30, 3181–3191. https://doi.org/10.1002/sim.4368
Bland, J.M., Altman, D.G., 1995a. Statistics notes: Calculating correlation coefficients with repeated observations: Part 1—correlation within subjects. BMJ 310, 446. https://doi.org/10.1136/bmj.310.6977.446
Bland, J.M., Altman, D.G., 1995b. Calculating correlation coefficients with repeated observations: Part 2—correlation between subjects. BMJ 310, 633. https://doi.org/10.1136/bmj.310.6980.633
Meinck, S., Rodriguez, M.C., 2013. Considerations for correlation analysis using clustered data: working with the teacher education and development study in mathematics (TEDS-M) and other international studies. Large-scale Assessments in Education 1, 7. https://doi.org/10.1186/2196-0739-1-7
Rosner, B., Glynn, R.J., 2017. Estimation of rank correlation for clustered data. Statistics in Medicine 36, 2163–2186. https://doi.org/10.1002/sim.7257
Rosner, R., 2016. Marginal Association Measures for Clustered Data.

## LME-residual approach

### LMM assumptions



### Within-modality

#### Glycans

##### V1: plate as mixed effect

Groups are non-nested, in the sense of Gelman2007, p244 ("overlapping categories"). This implies that HLMdiag *cannot* be used.

```{r glycan-lmer-plate-random}

glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age + (1|Plate_NO), glycans_raw)
# gives boundary fit (see ?isSingular)


# adjust all glycans
glycans_fam_adj_l <- list()
fits <- warns <- msgs <- list()
for (i in 6:ncol(glycans_raw)){
  
  # debug
  # i <- 7
  
  igx <- names(glycans_raw)[i]
  model_data <- cbind(glycans_raw[,1:5],
                      structure(glycans_raw[, ..i], names="glycan")) %>%
    dplyr::mutate_at(.vars = vars(FID,IID,Plate_NO, Sex), as.factor)
  tmp <- tryCatch.W.E(
    lmer(glycan ~ (1|FID) + (1|Plate_NO) + Sex*Age, model_data)
    )
  fits[[igx]] <- tmp$value
  warns[[igx]] <- tmp$warning
  msgs[[igx]] <- tmp$message
  
  glycans_fam_adj_l[[igx]] <- residuals(fits[[igx]])
}


glycans_fam_adj_old <-glycans_fam_adj_l %>%
  purrr::map(~tibble(res=.x, index=names(.x)) %>%
        dplyr::right_join(tibble(index=as.character(1:nrow(glycans_raw)))) %>%
        dplyr::select(res)) %>%
  dplyr::bind_cols() %>%
  rlang::set_names(names(glycans_fam_adj_l))



```


##### Troubleshoot

###### Problem outline

Problems:

- isSingular message for 80/151 glycans
- convergence warning for 10/151 glycans


Troubleshoot resources:
FAQ at https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html
  (sections "Convergence warnings" and "Singular models)
  
Convergence resources:
 - ?convergence
 - lme4 convergence warnings: troubleshooting at https://rstudio-pubs-static.s3.amazonaws.com/33653_57fc7b8e5d484c909b615d8633c01d51.html
 
 Singularity resources:
 - https://stats.stackexchange.com/questions/378939/dealing-with-singular-fit-in-mixed-models


```{r glycan-lmer-plate-random-troubleshoot, include=FALSE}
# reason for boundary fit: not that FID and plate are strictly aliased
dplyr::summarise_all(glycans_raw[,1:4],n_distinct)
glycans_raw %>%
  dplyr::group_by(FID) %>%
  dplyr::summarise(n_plates = n_distinct(Plate_NO)) %>%
  dplyr::count(n_plates)
# rather it seems that plate_NO is generating the warnings
glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|Plate_NO), glycans_raw)  # not ok
summary(glycans_fit)   # var(plate_NO)=0
glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age, glycans_raw)  # ok


## co-occurrence pattern of singularity messages and convergence warnings

# var(plate_no) is non-zero for 63% of glycans
plate_var <- fits %>%
  purrr::map(~broom::tidy(.x)) %>%
  purrr::map(~dplyr::filter(.x, term=="sd_(Intercept).Plate_NO")) %>%
  purrr::map_dbl("estimate")

boxplot(plate_var)
mean(plate_var==0)
plate_var_overview <- tibble(glycan=names(plate_var),
       plate_var=plate_var,
       msg = (glycan %in% names(msgs)),
       warn = (glycan %in% names(warns)))
# View(plate_var_overview)
# for isSingular message, there is a clear trend with plate_var
# for non-convergence warning, there does not seem to be such trend
plate_var_overview %>%
  tidyr::gather(output_type, value, -one_of("glycan", "plate_var")) %>%
  ggplot(aes(x=value, y=plate_var))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~output_type)+
  stat_n_text()


```


###### Try different optimizers (allFit), following ?convergence

IgG4_A2G has only the convergence problem.


```{r glycan-lmer-plate-random-allfit, include=FALSE}
# fit <- lmer(IgG4_A2G ~ (1|FID) + Sex*Age + (1|Plate_NO), glycans_raw)
# fit <- lmer(IgG4_A2G ~ (1|FID) + Sex*Age + (1|Plate_NO), glycans_raw,
#             control = lmerControl(optimizer = "nlminbwrap"))
# allfits <- allFit(fit)
# isOK <- sapply(allfits,is,"merMod")
# lapply(allfits[isOK],function(x) x@optinfo$conv$lme4$messages)

```


##### V2: plate as fixed effect

See section "Should I treat factor xxx as fixed or random?" in https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html

"For practical purposes, there must be a reasonable number of random-effects levels (e.g. blocks) – more than 5 or 6 at a minimum. This is not surprising if you consider that random effects estimation is trying to estimate an among-block variance"

ENI1H5N4F0S1 has only the singularity problem

```{r glycan-lmer-plate-fixed, include=FALSE}
fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age + Plate_NO, glycans_raw)  #ok

glycans_fam_adj <- readd(glycans_fam_adj)
```

Completely solves the singularity problem + reduces number of non-convergence warnings to 1 (LAGY_A2B). This is further resolved by using a different optimizer.

```{r glycan-lmer-plate-fixed-testcase, include=FALSE}
fit <- lmer(LAGY_A2B ~ (1|FID) + Sex*Age + Plate_NO, glycans_raw, 
            control = lmerControl(optimizer = "nlminbwrap"))
```

##### compare new to old residuals

```{r glycan-lmer-plate-fixedVSrandom, include=FALSE}

res_comp <- dplyr::bind_cols(
  tidyr::gather(glycans_fam_adj, glycan, new_res),
  tidyr::gather(glycans_fam_adj_old, glycan, old_res)
)

p_res <- ggplot(res_comp, aes(x=old_res, y=new_res))+
  geom_point(alpha=0.1)+
  theme_bw()

ggsave(filename = "residuals_wgcna_mixed-vs-fixed-plateNO.png", plot = p_res, path =figdir)

summary(abs(res_comp$old_res - res_comp$new_res), na.rm=TRUE)
summary(res_comp$new_res)

par(mfrow=c(1,2))
boxplot(abs(res_comp$old_res - res_comp$new_res), na.rm=TRUE)
boxplot(res_comp$new_res)

```


#### Immunophenotypes

### Cross-Modality

#### Glycans

```{r glycans}

# hist(glycan_cor[upper.tri(glycan_cor, diag = TRUE)])
# ComplexHeatmap::Heatmap(glycan_cor)


```

#### Immunophenotypes

```{r ips}

# # validate bigcor function on glycans
# testbigcor <- bigcor(x=as.data.frame(glycans[,-(1:6)]), nblocks = 10, use = "pairwise.complete.obs", method = "pearson")
# dim.ff(testbigcor) <- c(150*150,1)
# ffbase::hist.ff(testbigcor, breaks = 50)
# 
# # now apply to ips
# ips[,-(1:2)]
```


# WGCNA

Objective of WGCNA is not necessarily globally optimal partitioning, but rather detection of meaningful modules. Grey module is allowed to be very heterogeneous. How to deal with "grey" module?

- treat as other clusters, but ignore module-specific modularity contribution in calculation of global modularity?  <- current approach
- all grey members as singleton clusters?


Modularity based on similarity, adjacency or TOM? Different choice depending on whether modules defined based on adj or TOM?


## Glycans

### Including derived traits

```{r glycans-scale-free-softpower}
glycans_scale_free <- readd(glycans_scale_free)
# View(glycans_scale_free$sft_df)
glycans_scale_free$p_rsq
glycans_scale_free$p_k

#low rsq with power distribution (scale free topology): because not independent entities but related measurements?
```




```{r glycans-parameter-exploration}

glycan_module_stats <- readd(glycan_module_stats)

# object.size(glycan_module_stats) %>% format(units="MB")
# saveRDS(glycan_module_stats, file = glue("{datadir}/glycan_module_stats.RDS"))
# glycan_module_stats <- readRDS(glue("{datadir}/glycan_module_stats.RDS"))
# View(glycan_module_stats$color_overview)

#scale module-wise modularities?
glycan_module_stats$plots[[6]]
glycan_module_stats$merge_pars_used
glycan_module_stats$mod_modularities

# calculate total non-grey modularity, based on weights in adj or in TOM, but with module definition always based on TOM
# remark: sometimes adj-based module definition might be better 
#TODO: retrieve ref for remark


for (i in seq_along(glycan_module_stats$plots)){
  draw(glycan_module_stats$plots[[i]], column_title = glue("Network {i}"))
}


```



In IgA:

- In HYT (IgA - Ser89-126): three blocks with strong positive intra-block and negative inter-block correlations:

    - H>3, high S
    - H>3, low S
    - H < 5

- cluster of "Bisection of diantennary structures" for different sites, and some of the raw glycans contributing to the derived trait at those

In IgG:

- IgGI low fucose, low SA cluster


### Excluding derived traits


```{r glycans-scale-free-softpower-noderiv}
glycans_scale_free_noderiv <- readd(glycans_scale_free_noderiv)
# View(glycans_scale_free$sft_df)

glycans_scale_free_noderiv$p_rsq
glycans_scale_free_noderiv$p_k

#low rsq with power distribution (scale free topology): because not independent entities but related measurements?
```


```{r glycans-parameter-exploration-noderiv}

glycan_module_stats_noderiv <- readd(glycan_module_stats_noderiv)

#scale module-wise modularities?
glycan_module_stats$plots[[6]]
glycan_module_stats$merge_pars_used
glycan_module_stats$mod_modularities

# calculate total non-grey modularity, based on weights in adj or in TOM, but with module definition always based on TOM
# remark: sometimes adj-based module definition might be better 
#TODO: retrieve ref for remark


#generate plots

  
for (i in seq_along(glycan_module_stats$plots)){
  draw(glycan_module_stats$plots[[i]], column_title = glue("Network {i}"))
}


```

Compared to WGCNA including derivered traits:

Optimal set parameter set is the same (network 2, iteration 3), with slightly higher maximal modularity in the network excluding derived traits.

In IgA:

- In HYT (IgA - Ser89-126): *recovered* three blocks with strong positive intra-block and negative inter-block correlations:

    - H>3, high S
    - H>3, low S
    - H < 5

- cluster of "Bisection of diantennary structures" for different sites, and some of the raw glycans contributing to the derived trait at those sites: *not retrieved*

In IgG:

- IgGI low fucose, low SA cluster *is recovered*

### General remarks

Negative correlations can carry important information, especially when the glycans are separated by addition/removal of a single sugar moiety.

To assure this

  1) Structure of the glycan would need to be known
  2) Biological evidence of the reaction, e.g. compiled in database such as KEGG?
  
  But: sialic acid typically terminal -> excellent candidate

Examples: 
ENI1H5N4F0S1 and ENI1H5N4F0S2 are strongly negatively correlated.
LAGY1H5N4F0S2 and LAGY1H5N4F0S1 are strongly positively correlated.

Could relate to:
- regulation of reaction: constitutive versus induced?
- opposite associations with IPs?

Some derived traits might be driven primarily by a single glycan. Example: ENI_A2S and ENI1H5N4F0S2

-> Possible to assess 'relevance' of derived traits by variance decomposition?



## immunophenotypes

```{r wgcna-ip-memory-calc}
# https://peterlangfelder.com/2018/11/25/blockwise-network-analysis-of-large-data/

mem_needed <- function(n_feat){
  bytes <-n_feat^2*8*3
  gigabytes <- bytes/2^(10*3)
  gigabytes
}

max_block_size <- function(GB_RAM){
  bytes <- GB_RAM*2^(10*3)
  n_feat <- sqrt(bytes/24)
  n_feat
}

n_good_ips <- length(good_ips)
n_ips <- ncol(ips)-2
mem_needed(n_good_ips)  #33 GB
mem_needed(n_ips)  #180 GB

max_block_size(64)

```



    

    



# References {#references .unnumbered}




