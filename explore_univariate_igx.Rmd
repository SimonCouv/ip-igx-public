---
title: "explore_univariate_igx"
author: 
  - name: "Simon Couvreur"
    email: alice@example.com
    affiliation: Some Institute of Technology
    corresponding: alice@example.com
  - name: Bob Security
    email: bob@example.com
    affiliation: Another University
address:
  - code: Some Institute of Technology
    address: Department, Street, City, State, Zip
  - code: Another University
    address: Department, Street, City, State, Zip
abstract: |
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur eget porta erat. Morbi consectetur est vel gravida pretium. Suspendisse ut dui eu ante cursus gravida non sed sem. Nullam sapien tellus, commodo id velit id, eleifend volutpat quam. Phasellus mauris velit, dapibus finibus elementum vel, pulvinar non tellus. Nunc pellentesque pretium diam, quis maximus dolor faucibus id. Nunc convallis sodales ante, ut ullamcorper est egestas vitae. Nam sit amet enim ultrices, ultrices elit pulvinar, volutpat risus.
  
author_summary: |
  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur eget porta erat. Morbi consectetur est vel gravida pretium. Suspendisse ut dui eu ante cursus gravida non sed sem. Nullam sapien tellus, commodo id velit id, eleifend volutpat quam. Phasellus mauris velit, dapibus finibus elementum vel, pulvinar non tellus. Nunc pellentesque pretium diam, quis maximus dolor faucibus id. Nunc convallis sodales ante, ut ullamcorper est egestas vitae. Nam sit amet enim ultrices, ultrices elit pulvinar, volutpat risus.
  
output: rticles::plos_article
csl: plos.csl
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
library(tidyverse)
library(data.table)
library(lattice)
# library(cowplot)
library(ggforce)
library(gridExtra)
library(ComplexHeatmap)
library(WGCNA)
library(lme4)
library(EnvStats)
library(naniar)
library(glue)
library(igraph)
library(citr)
library(GGally)
library(sjPlot)
library(here)
library(knitr)

figdir <- here("results/figures")
resultdir <- here("results")
cluster_pars_dir <- here("WGCNA_parameters")
datadir <- here("data")

knitr::opts_chunk$set(echo = FALSE,
                      dev=c("png", "pdf"),
                      fig.path = here("results/figures/report/"))


```

```{r functions-source}
# see make.R
# otherwise: self-invalidation, see ?make
```


```{r functions-local}
scatter_smooth <- function(data, mapping,size=4, corfnc = "spearman"){
  x_name <- quo_text(mapping$x)
  y_name <- quo_text(mapping$y)
  x_pos = 0.5*(max(data[,x_name], na.rm = TRUE)-min(data[,x_name], na.rm = TRUE))
  y_pos =  0.9*(max(data[,y_name], na.rm = TRUE)-min(data[,y_name], na.rm = TRUE))
  sp_cor = round(cor(data[,x_name], data[,y_name], 
               method = corfnc, 
               use = "pairwise.complete.obs"),
               digits=3
  )
  cor_prefix <- substr(corfnc,1,2)
  
  n <- nrow(data %>% dplyr::select(c(x_name, y_name)) %>% drop_na())
  ggplot(data=data,mapping=mapping)+
    geom_point(size=0.5, alpha=0.3)+
    geom_smooth(alpha=0.3, color="black", size=0.5)+
    # geom_smooth(alpha=0.3, color="black", size=0.5, method = "gam", formula = y ~ s(x, bs = "cs"))+
    annotate("text", Inf, Inf, label=sprintf("n=%s\n%s cor=%s",n, cor_prefix,sp_cor),vjust = "inward", hjust = "inward",
             size=size)
    # stat_n_text(aes(x=10,y=10, group="combo"))
}



# see demo(error.catching) http://r.789695.n4.nabble.com/capturing-warnings-within-loops-so-I-know-the-iterations-where-warnings-occurred-td4676786.html
tryCatch.W.E <- function(expr)
{
  W <- NULL
  w.handler <- function(w){ # warning handler
    W <<- w
    invokeRestart("muffleWarning")
  }
  M <- NULL
  m.handler <- function(m){ # warning handler
    M <<- m
    # invokeRestart("muffleWarning")
  }
  list(value = withCallingHandlers(tryCatch(expr, error = function(e) e),
                                   warning = w.handler,
                                   message = m.handler),
       warning = W,
       message = M)
}
# 
# tryCatch.W.E_original <- function(expr)
# {
#   W <- NULL
#   w.handler <- function(w){ # warning handler
#     W <<- w
#     invokeRestart("muffleWarning")
#   }
#   # M <- NULL
#   # m.handler <- function(m){ # warning handler
#   #   M <<- m
#   #   # invokeRestart("muffleWarning")
#   # }
#   list(value = withCallingHandlers(tryCatch(expr, error = function(e) e),
#                                    warning = w.handler),
#        warning = W)
# }

# str(tryCatch.W.E(warning("hi")))

```




# Preprocessing

Note 618 (13455158 - 13454540) lines were removed, which is more than the 604 mentioned by Alessia.

```{r remove-error-lines}
# 
# f <- file(here("input_data/glycans_20190409_immunopheno_corrected.tsv.gz"), open="r")
# o <- file(here("input_data/glycans_20190409_immunopheno_corrected_cleanedSimon.tsv.gz"), open = "a")
# i <- 1
# 
# while (TRUE){
#   if (i%%100000==0)
#     print(i)
#   
#   line <- readLines(f, n=1)
#   if(str_count(line, "\t")==16){
#     writeLines(text=line, con=o)
#   }
#   i <- i+1
# }
```


```{r read-data}

# glycans
glycans <- readd(glycans)
glycans_raw <- readd(glycans_raw)

# IPs
ips <- readd(ips)

#Popante output
ip_igx_univar <- readd(ip_igx_univar)


# annotations
ip_anno <- readd(ip_anno)
IgA_anno_names_raw <- readd(IgA_anno_names_raw)
IgA_anno_names_derived <- readd(IgA_anno_names_derived)
twin_fam <-readd(twin_fam)

```

## data preprocessing

```{r QC-filter}

ip_igx_univar_good <- readd(ip_igx_univar_good)

good_ips <- ip_anno$set_name[ip_anno$robust_mario_qc == "Good"] %>% na.omit()
ips_qc <- ips %>%
  dplyr::select(!!good_ips)

```


# Quality control

drake issue: including images can be problematic. Since they are not located in the code chunks/inline code, there is no dependency being generated?

p-value QQ-plot:






```{r missing-data}

# `r sprintf("![](%s)", glue("{figdir}/univar_qqplot.png")`

naniar::vis_miss(glycans_raw)

```


# Data exploration

## IgX features

### Annotations

99 IgA features (input==results)

- 71 raw
- 28 derived

But in annotations:

- 75 raw
- 52 derived

When examining set diffs (see sheet 'overview'):

- 29 raw anno names not in inputs/results
    - 6 peptide clusters
    - 13 LAGCa/b
    - 10 reason unclear
- 25 input/results names not in raw anno names (29-25=75-71)
    - reason unclear for all
- Out of 28 derived input/results names and 52 derived anno names, only 6 are overlapping


52 IgG features, but no annotation?



```{r IgA-glycan-features-anno}

# in univariate results
IgA_names_univar <- unique(ip_igx_univar_good$response) %>% .[!str_detect(., pattern = "IgG")]

# in corrected glycan data
IgA_names_input <- names(glycans)[-(1:5)]  %>% .[!str_detect(., pattern = "IgG")]

# n_input == n_results
setequal(IgA_names_univar, IgA_names_input)

# split in raw and derived
IgA_names_univar_raw <- IgA_names_univar[1:71]
IgA_names_univar_derived <- IgA_names_univar[72:99]


# annotated names not in input/results -------

#raw
# note: in input/results raw names are coded as e.g. HYT1H2N5F0S2 while in anno they are HYT_H2N5F0S2
setdiff(IgA_anno_names_raw$feature %>% str_replace("_","1"), IgA_names_univar_raw) %>% 
  writeLines(., glue("{resultdir}/anno_raw_noresult.txt"))
setdiff(IgA_names_univar_raw, IgA_anno_names_raw$feature %>% str_replace("_","1")) %>% 
  writeLines(.,glue("{resultdir}/result_raw_no_anno.txt"))

#derived
# note: derived names have same coding in all sets
setdiff(IgA_anno_names_derived$feature, IgA_names_univar_derived)
setdiff(IgA_names_univar_derived, IgA_anno_names_derived$feature)
intersect(IgA_names_univar_derived, IgA_anno_names_derived$feature)
length(union(IgA_names_univar_derived, IgA_anno_names_derived$feature))

```

### Marginal distributions

see PDF


## IP features

### Missingness of annotation fields

```{r}
gg_miss_var(ip_anno, show_pct = TRUE)
```

### Find higher grouping of IPs

'composite_lin_source':

- for lineage/MFI features: 'Source' column (value = 'Lin' or 'MFI')
- 'Lineage' for all others (value=lineage on which the subset is calculated)

```{r}
count(ip_anno, composite_lin_source) %>% 
  arrange(desc(n)) %>%
  View()
  
```


## Number of significant associations ~ FDR threshold

```{r n-sign-ass-FDR}
plot(ecdf(ip_igx_univar_good$pv_adj_global),
     xlab = "FDR",
     ylab = "prop associations < FDR")

ip_igx_univar_good %>%
  summarise(n_FDR20 = sum(pv_adj_global <0.2),
            n_FDR10 = sum(pv_adj_global <0.1),
            n_FDR5 = sum(pv_adj_global <0.05),
            n_FDR1 = sum(pv_adj_global <0.01))

ecdf_abs <- function(x){
  e <- ecdf(x)
  function(t){e(t)*length(x)}
}
ecdf_logabs <- function(x){
  e <- ecdf(x)
  function(t){log10(e(t)*length(x))}
}

fdr20_ecdf <- ecdf_abs(ip_igx_univar_good$pv_adj_global %>% .[. < 0.2])
plot(fdr20_ecdf, xlim = c(0,0.2),
     xlab = "FDR",
     ylab = "n associations < FDR")

fdr_ecdf <- ecdf_abs(ip_igx_univar_good$pv_adj_global)
plot(fdr_ecdf,
     xlab = "FDR",
     ylab = "n associations < FDR")

fdr_log_ecdf <- ecdf_logabs(ip_igx_univar_good$pv_adj_global)
plot(fdr_log_ecdf,
     xlab = "FDR",
     ylab = "log10(n associations < FDR)")

```

## Number of significantly associated features per omic ~ FDR threshold


```{r n-sign-ass-features-FDR}

n_associated_m <- readd(n_associated_m)

ggplot(ungroup(n_associated_m), aes(x=fdr_threshold, y=prop, colour=omic))+
  geom_line()+
  theme_bw()+
  # facet_zoom(x = fdr_threshold < 0.25)
  facet_zoom(xlim = c(0,0.2))+
  xlab("FDR threshold")+
  ylab("proportion of features with association < FDR")

```


## Explore top associations

```{r top-associations}
ip_igx_univar_good_anno <- readd(ip_igx_univar_good_anno)


arrange(ip_igx_univar_good_anno, pvalue) %>% dplyr::select(response, IgX, predictor, composite_lin_source, pvalue) %>% head(100)

ip_igx_univar_good_anno %>%
  head(10000) %>% 
  count(IgX, composite_lin_source)%>%
  arrange(IgX, desc(n)) %>% 
  View()


```


### Top asssociations scatter
see PDF

### Enrichment of subgroups

#### At 5% FDR level

##### IP subgroup enrichment - overall

```{r}

ip_lin_source_enrich_overall <- ip_igx_univar_good_anno %>%
  dplyr::filter(pv_adj_global < 0.05) %>%
  count(composite_lin_source) %>%
  left_join(count(ip_anno, composite_lin_source),
            by = "composite_lin_source", 
            suffix = c("_assoc", "_feat")) %>% 
  mutate(`n_assoc/n_feat` = n_assoc/n_feat,
         `prop(n_assoc)` = n_assoc/sum(n_assoc)
         # `prop(n_assoc/n_feat)` = `n_assoc/n_feat`/sum(`n_assoc/n_feat`)
         ) %>% 
  dplyr::select(composite_lin_source, n_assoc, n_feat, `n_assoc/n_feat`, everything()) %>% 
  arrange(desc(`n_assoc/n_feat`))
write_csv(ip_lin_source_enrich_overall, path = glue("{resultdir}/ip_lin_source_enrich_overall.csv"))

```

##### IP subgroup enrichment - by IgX

```{r}
ip_lin_source_enrich_byIgX <- ip_igx_univar_good_anno %>%
  dplyr::filter(pv_adj_global < 0.05) %>%
  count(composite_lin_source, IgX) %>%
  left_join(count(ip_anno, composite_lin_source),
            by = "composite_lin_source", 
            suffix = c("_assoc", "_feat")) %>% 
  group_by(IgX) %>% 
  mutate(`n_assoc/n_feat` = n_assoc/n_feat,
         `prop(n_assoc)` = n_assoc/sum(n_assoc)
         # `prop(n_assoc/n_feat)` = `n_assoc/n_feat`/sum(`n_assoc/n_feat`)
         ) %>% 
  dplyr::select( IgX,composite_lin_source, n_assoc, n_feat, `n_assoc/n_feat`, everything()) %>% 
  arrange(IgX, desc(`n_assoc/n_feat`))
write_csv(ip_lin_source_enrich_byIgX, path = glue("{resultdir}/ip_lin_source_enrich_byIgX.csv"))


```



#### continuous ~ FDR

##### IgX subgroup enrichment

```{r glycan-IgG-enrich}

# running_IgG_perc <- c()
# for (i in 1:nrow(ip_igx_univar_good)){
#   running_IgG_perc <- head(ip_igx_univar_good$response, i) %>% str_detect(., pattern = "IgG") %>% mean(.)
# }

running_IgG_perc <-  readd(running_IgG_perc)

p_IgG_enrich <- tibble(cum_IgG_perc = running_IgG_perc,
                       index = 1:length(running_IgG_perc)) %>% 
  .[c(1:10000,seq(10000,length(running_IgG_perc), 100)),] %>%
  ggplot(aes(x=index,y=cum_IgG_perc))+
  geom_line()+
  scale_x_log10()

## gssave not require once Rmd becomes easily renderable
# ggsave(p_IgG_enrich, filename = glue("{figdir}/p_IgG_enrich.png"),
#        width = 6, height = 6, dpi = 600)

```

##### Lin-source enrichment

Overall:

```{r ip-lin_source-enrich}

lin_source_props_df <- readd(lin_source_props_df)

p_lin_source_enrich <- lin_source_props_df %>%
  tidyr::gather(lin_source, prop, -one_of("top","weighting")) %>%
  ggplot(aes(x=top, y=prop, color=lin_source, group=lin_source))+
  geom_line()+
  scale_x_log10()+
  facet_wrap(weighting~.)
# ggsave(p_lin_source_enrich, filename = glue("{figdir}/p_lin_source_enrich.png"),
#        width = 6, height = 6, dpi = 600)


```

By IgX:

```{r lin_source-enrich-by-IgX}

lin_source_IgX_props_df <- readd(lin_source_IgX_props_df)

# plot
p_lin_source_IgX_enrich <- lin_source_IgX_props_df %>%
  tidyr::gather(lin_source, prop, -one_of(c("top", "IgX"))) %>%
  ggplot(aes(x=top, y=prop, color=lin_source, group=lin_source))+
  geom_line()+
  scale_x_log10()+
  facet_grid(IgX~.)
# ggsave(p_lin_source_IgX_enrich, filename = glue("{figdir}/p_lin_source_IgX_enrich.png"),
#        width = 6, height = 6, dpi = 600)


```



## Correlation structures

```{r glycans}

# glycans
glycan_cor <- readd(glycan_cor)
hist(glycan_cor[upper.tri(glycan_cor, diag = TRUE)])

ComplexHeatmap::Heatmap(glycan_cor)


```

```{r ips}

# # validate bigcor function on glycans
# testbigcor <- bigcor(x=as.data.frame(glycans[,-(1:6)]), nblocks = 10, use = "pairwise.complete.obs", method = "pearson")
# dim.ff(testbigcor) <- c(150*150,1)
# ffbase::hist.ff(testbigcor, breaks = 50)
# 
# # now apply to ips
# ips[,-(1:2)]
```


# WGCNA glycans

## family-adjusted correlations

### V1: plate as mixed effect

```{r}

glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age + (1|Plate_NO), glycans_raw)
# gives boundary fit (see ?isSingular)


# adjust all glycans
glycans_fam_adj_l <- list()
fits <- warns <- msgs <- list()
for (i in 6:ncol(glycans_raw)){
  
  # debug
  # i <- 7
  
  igx <- names(glycans_raw)[i]
  model_data <- cbind(glycans_raw[,1:5],
                      structure(glycans_raw[, ..i], names="glycan")) %>%
    dplyr::mutate_at(.vars = vars(FID,IID,Plate_NO, Sex), as.factor)
  tmp <- tryCatch.W.E(
    lmer(glycan ~ (1|FID) + (1|Plate_NO) + Sex*Age, model_data)
    )
  fits[[igx]] <- tmp$value
  warns[[igx]] <- tmp$warning
  msgs[[igx]] <- tmp$message
  
  glycans_fam_adj_l[[igx]] <- residuals(fits[[igx]])
}


glycans_fam_adj_old <-glycans_fam_adj_l %>%
  purrr::map(~tibble(res=.x, index=names(.x)) %>%
        dplyr::right_join(tibble(index=as.character(1:nrow(glycans_raw)))) %>%
        dplyr::select(res)) %>%
  dplyr::bind_cols() %>%
  rlang::set_names(names(glycans_fam_adj_l))



```


### Troubleshoot

#### Problem outline

Problems:

- isSingular message for 80/151 glycans
- convergence warning for 10/151 glycans


Troubleshoot resources:
FAQ at https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html
  (sections "Convergence warnings" and "Singular models)
  
Convergence resources:
 - ?convergence
 - lme4 convergence warnings: troubleshooting at https://rstudio-pubs-static.s3.amazonaws.com/33653_57fc7b8e5d484c909b615d8633c01d51.html
 
 Singularity resources:
 - https://stats.stackexchange.com/questions/378939/dealing-with-singular-fit-in-mixed-models


```{r}
# reason for boundary fit: not that FID and plate are strictly aliased
dplyr::summarise_all(glycans[,1:4],n_distinct)
glycans_raw %>%
  dplyr::group_by(FID) %>%
  dplyr::summarise(n_plates = n_distinct(Plate_NO)) %>%
  dplyr::count(n_plates)
# rather it seems that plate_NO is generating the warnings
glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|Plate_NO), glycans_raw)  # not ok
summary(glycans_fit)   # var(plate_NO)=0
glycans_fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age, glycans_raw)  # ok


## co-occurrence pattern of singularity messages and convergence warnings

# var(plate_no) is non-zero for 63% of glycans
plate_var <- fits %>%
  purrr::map(~broom::tidy(.x)) %>%
  purrr::map(~dplyr::filter(.x, term=="sd_(Intercept).Plate_NO")) %>%
  purrr::map_dbl("estimate")

boxplot(plate_var)
mean(plate_var==0)
plate_var_overview <- tibble(glycan=names(plate_var),
       plate_var=plate_var,
       msg = (glycan %in% names(msgs)),
       warn = (glycan %in% names(warns)))
View(plate_var_overview)
# for isSingular message, there is a clear trend with plate_var
# for non-convergence warning, there does not seem to be such trend
plate_var_overview %>%
  tidyr::gather(output_type, value, -one_of("glycan", "plate_var")) %>%
  ggplot(aes(x=value, y=plate_var))+
  geom_boxplot()+
  theme_bw()+
  facet_wrap(~output_type)+
  stat_n_text()


```


#### Try different optimizers (allFit), following ?convergence

IgG4_A2G has only the convergence problem.



```{r, include=FALSE}
fit <- lmer(IgG4_A2G ~ (1|FID) + Sex*Age + (1|Plate_NO), glycans_raw)
fit <- lmer(IgG4_A2G ~ (1|FID) + Sex*Age + (1|Plate_NO), glycans_raw,
            control = lmerControl(optimizer = "nlminbwrap"))
allfits <- allFit(fit)
isOK <- sapply(allfits,is,"merMod")
lapply(allfits[isOK],function(x) x@optinfo$conv$lme4$messages)

```


#### Plate_NO as fixed effect, because max 2 levels within FID?

See section "Should I treat factor xxx as fixed or random?" in https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html

"For practical purposes, there must be a reasonable number of random-effects levels (e.g. blocks) – more than 5 or 6 at a minimum. This is not surprising if you consider that random effects estimation is trying to estimate an among-block variance"

ENI1H5N4F0S1 has only the singularity problem

```{r}
fit <- lmer(ENI1H5N4F0S1 ~ (1|FID) + Sex*Age + Plate_NO, glycans_raw)  #ok

# adjust all glycans
glycans_fam_adj_l <- list()
fits <- warns <- msgs <- list()
for (i in 6:ncol(glycans_raw)){
  
  # debug
  # i <- 7
  
  igx <- names(glycans_raw)[i]
  model_data <- cbind(glycans_raw[,1:5],
                      structure(glycans_raw[, ..i], names="glycan"))
  tmp <- tryCatch.W.E(
    lmer(glycan ~ (1|FID) + Plate_NO + Sex*Age, model_data)
    )
  fits[[igx]] <- tmp$value
  warns[[igx]] <- tmp$warning
  msgs[[igx]] <- tmp$message
  
  glycans_fam_adj_l[[igx]] <- residuals(fits[[igx]])
}
```

Completely solves the singularity problem + reduces number of non-convergence warnings to 1 (LAGY_A2B). This is further resolved by using a different optimizer.

```{r}
fit <- lmer(LAGY_A2B ~ (1|FID) + Sex*Age + Plate_NO, glycans_raw, 
            control = lmerControl(optimizer = "nlminbwrap"))
```


### V2: plate as fixed effect

```{r}
# adjust all glycans
glycans_fam_adj_l <- list()
fits <- warns <- msgs <- list()
for (i in 6:ncol(glycans_raw)){
  
  # debug
  # i <- 7
  
  igx <- names(glycans_raw)[i]
  model_data <- cbind(glycans_raw[,1:5],
                      structure(glycans_raw[, ..i], names="glycan"))%>%
    mutate_at(.vars = vars(FID,IID,Plate_NO, Sex), as.factor)
  tmp <- tryCatch.W.E(
    lmer(glycan ~ (1|FID) + Plate_NO + Sex*Age, model_data, 
            control = lmerControl(optimizer = "nlminbwrap"))
    )
  fits[[igx]] <- tmp$value
  warns[[igx]] <- tmp$warning
  msgs[[igx]] <- tmp$message
  
  glycans_fam_adj_l[[igx]] <- residuals(fits[[igx]])
}


# names of residuals correspond to row index of glycans_raw (those which are not NA)
head(which(!is.na(glycans_raw$ENI1H5N4F0S1)))
all.equal(as.character(which(!is.na(glycans_raw$ENI1H5N4F0S1))),
          names(glycans_fam_adj_l$ENI1H5N4F0S1))

glycans_fam_adj <-glycans_fam_adj_l %>%
  map(~tibble(res=.x, index=names(.x)) %>%
        dplyr::right_join(tibble(index=as.character(1:nrow(glycans_raw))),by="index") %>%
        dplyr::select(res)) %>%
  dplyr::bind_cols() %>%
  rlang::set_names(names(glycans_fam_adj_l))


```

### compare new to old residuals

```{r}

res_comp <- dplyr::bind_cols(
  tidyr::gather(glycans_fam_adj, glycan, new_res),
  tidyr::gather(glycans_fam_adj_old, glycan, old_res)
)

p_res <- ggplot(res_comp, aes(x=old_res, y=new_res))+
  geom_point(alpha=0.1)+
  theme_bw()

ggsave(filename = "residuals_wgcna_mixed-vs-fixed-plateNO.png", plot = p_res, path =figdir)

summary(abs(res_comp$old_res - res_comp$new_res), na.rm=TRUE)
summary(res_comp$new_res)

par(mfrow=c(1,2))
boxplot(abs(res_comp$old_res - res_comp$new_res), na.rm=TRUE)
boxplot(res_comp$new_res)

```




## WGCNA procedure

```{r scale-free-softpower}
powers = c(c(1:10), seq(from = 12, to=20, by=2))
common_pars <- list(data=glycans_fam_adj, verbose= 0,  moreNetworkConcepts = TRUE, powerVector = powers)
pars <- expand.grid(networktype = c('signed', 'signed hybrid', 'unsigned'),
            corFnc = c('cor', 'bicor'),
            stringsAsFactors = FALSE)

glycans_scale_free <- optimize_network_pars(common_pars, pars, powers, plt_title = "glycans")
View(glycans_scale_free$sft_df)
png(glue("{figdir}/WGCNA_pars/glycans_rsq.png"))
glycans_scale_free$p_rsq
dev.off()

glycans_scale_free$p_rsq
glycans_scale_free$p_k

#low rsq with power distribution (scale free topology): because not independent entities but related measurements?
```


Objective of WGCNA is not necessarily globally optimal partitioning, but rather detection of meaningful modules. Grey module is allowed to be very heterogeneous. How to deal with "grey" module?

- treat as other clusters, but ignore module-specific modularity contribution in calculation of global modularity?  <- current approach
- all grey members as singleton clusters?


Modularity based on similarity, adjacency or TOM? Different choice depending on whether modules defined based on adj or TOM?

```{r parameter-exploration}
glycan_cross_iter_pars <- list(data=glycans_fam_adj, data_name="glycans", figdir = glue("{figdir}/WGCNA_pars"))

glycan_network_pars <- read_tsv(glue("{cluster_pars_dir}/glycan_pars.tsv")) %>%
  dplyr::select(-aim)
glycan_cut_pars <- expand.grid(deep =c(4, 1),
                               minModuleSize=c(3,5,10,20))
glycan_modality <- ifelse(str_detect(names(glycans_fam_adj), pattern = "IgG"),"IgG","IgA")

# debug(wgcna_parameter_search)
glycan_module_stats <- wgcna_parameter_search(glycan_network_pars, 
                                              glycan_cut_pars,
                                              glycan_cross_iter_pars, 
                                              create_plot = TRUE,
                                              feat_modality=glycan_modality)

# object.size(glycan_module_stats) %>% format(units="MB")
saveRDS(glycan_module_stats, file = glue("{datadir}/glycan_module_stats.RDS"))
glycan_module_stats <- readRDS(glue("{datadir}/glycan_module_stats.RDS"))
View(glycan_module_stats$color_overview)

#scale module-wise modularities?
glycan_module_stats$plots[[6]]
glycan_module_stats$merge_pars_used
glycan_module_stats$mod_modularities

# calculate total non-grey modularity, based on weights in adj or in TOM, but with module definition always based on TOM
# remark: sometimes adj-based module definition might be better 
#TODO: retrieve ref for remark
modularity_overview <- map(glycan_module_stats$mod_modularities, 
    ~map(.x, ~rownames_to_column(.x) %>%
          dplyr::filter(rowname != "grey") %>%
          dplyr::select(-rowname) %>%
          dplyr::summarise_all(sum)) %>%
     dplyr::bind_rows(.id="cut_iter")) %>%
  dplyr::bind_rows(.id="network_iter") %>%
  dplyr::mutate(cut_iter = str_match(cut_iter, pattern = "cut_iter_([:digit:]+)")[,2]) %>%
  dplyr::arrange(desc(adj_mod_modularities)) %>%
  dplyr::left_join(rownames_to_column(glycan_network_pars), by=c("network_iter" = "rowname")) %>% 
  dplyr::left_join(rownames_to_column(glycan_cut_pars), by=c("cut_iter" = "rowname"))
View(modularity_overview)
write_csv(modularity_overview, path = glue("{resultdir}/modularity_overview.csv"))


#generate plots
pdf(file= glue("{figdir}/WGCNA_pars/overview.pdf"),
    pointsize = 2,
    width = 10,
    height=10)
for (i in seq_along(glycan_module_stats$plots)){
  draw(glycan_module_stats$plots[[i]], column_title = glue("Network {i}"))
}
dev.off()
  
for (i in seq_along(glycan_module_stats$plots)){
  
  png(filename = glue("{figdir}/WGCNA_pars/network_{i}.png"),
      width = 10,
      height=10,
      units="in",
      res=600)
  draw(glycan_module_stats$plots[[i]], column_title = glue("Network {i}"))
  dev.off()
}


```



In IgA:

- In HYT (IgA - Ser89-126): three blocks with strong positive intra-block and negative inter-block correlations:

    - H>3, high S
    - H>3, low S
    - H < 5

- cluster of "Bisection of diantennary structures" for different sites, and some of the raw glycans contributing to the derived trait at those

In IgG:

- IgGI low fucose, low SA cluster

# WGCNA immunophenotypes

```{r memory-calc}
# https://peterlangfelder.com/2018/11/25/blockwise-network-analysis-of-large-data/

mem_needed <- function(n_feat){
  bytes <-n_feat^2*8*3
  gigabytes <- bytes/2^(10*3)
  gigabytes
}

max_block_size <- function(GB_RAM){
  bytes <- GB_RAM*2^(10*3)
  n_feat <- sqrt(bytes/24)
  n_feat
}

n_good_ips <- length(good_ips)
n_ips <- ncol(ips)-2
mem_needed(n_good_ips)  #33 GB
mem_needed(n_ips)  #180 GB

max_block_size(64)

```


## family-adjusted correlations

### Literature on estimation of bivariate correlation from clustered/multi-level/hierarchical samples

Problem statement: for each sample two or more variables are observed, but samples are correlated (here, due to being twins).

unanswered SO: https://stats.stackexchange.com/questions/81220/multivariate-mixed-model-in-nlme



Luo, J., D’Angelo, G., Gao, F., Ding, J., Xiong, C., 2015. Bivariate correlation coefficients in family-type clustered studies. Biometrical Journal 57, 1084–1109. https://doi.org/10.1002/bimj.201400131

*But how to implement?*

From following refs it seems that only within-cluster BCC is estimable with lme4.

However, the models of Luo2015 is also implemented on melted data! (see their appendix)

method via melting the data (multivariate -> repeated measures) in lme4
https://mac-theobio.github.io/QMEE/MultivariateMixed.html#a-trick-to-do-multivariate-mixed-models-using-lme4
http://rpubs.com/bbolker/3336
https://stackoverflow.com/questions/7831243/multivariate-linear-mixed-model-in-lme4



Other refs:
Lorenz, D.J., Datta, S., Harkema, S.J., 2011. Marginal association measures for clustered data. Stat Med 30, 3181–3191. https://doi.org/10.1002/sim.4368
Bland, J.M., Altman, D.G., 1995a. Statistics notes: Calculating correlation coefficients with repeated observations: Part 1—correlation within subjects. BMJ 310, 446. https://doi.org/10.1136/bmj.310.6977.446
Bland, J.M., Altman, D.G., 1995b. Calculating correlation coefficients with repeated observations: Part 2—correlation between subjects. BMJ 310, 633. https://doi.org/10.1136/bmj.310.6980.633
Meinck, S., Rodriguez, M.C., 2013. Considerations for correlation analysis using clustered data: working with the teacher education and development study in mathematics (TEDS-M) and other international studies. Large-scale Assessments in Education 1, 7. https://doi.org/10.1186/2196-0739-1-7
Rosner, B., Glynn, R.J., 2017. Estimation of rank correlation for clustered data. Statistics in Medicine 36, 2163–2186. https://doi.org/10.1002/sim.7257
Rosner, R., 2016. Marginal Association Measures for Clustered Data.


### LMM assumptions

From [@harrisonBriefIntroductionMixed2018]:

- additivity of linear predictors
- residuals:

    - homoscedastic
    - normal
    - independent
    
```{r}


```
    
    



# References {#references .unnumbered}




